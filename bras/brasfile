########################################################################
#
# This brasfile is used to install bras from the source distribution. 
#
# Invoke processing of this file by typing
#
#   tclsh bras
#
# in the current directory. To change any of the following
# installation directories, assign values on the command line like
#
#   tclsh bras prefix=/halli/galli
#
########################################################################

getenv prefix /usr/local

## Directory where to put the executable script
getenv BINDIR [file join $prefix bin]

## Directory where to put the manual page
getenv MANDIR [file join $prefix man man1]

## Directory where to put the package files (*.tcl and the like)
## If you want to use bras as a packege loaded like
##   package require bras
## then [file dir] of this directory must be in your TCLLIBPATH or you
## must explicitly add it to auto_path in your Tcl-script.
getenv LIBDIR [file join $prefix lib bras-$::bras::VERSION]

## Directory where to put assorted documentation files
getenv DOCDIR [file join $prefix doc bras-$::bras::VERSION]

## You may explicitely override this on the command line with
## something like
##    TCLSH=mytclsh
## The value is entered into the main script to allow UNIX-like start
## of the script as an executable file.
getenv TCLSH tclsh8.0

########################################################################
include [file join $::bras::base install.rule]

## Lists of files we want to install
set BINTARGETS [file join $BINDIR bras 0755]

foreach f [concat braspkg.tcl pkgIndex.tcl [glob *.rule]] {
  lappend LIBTARGETS [file join $LIBDIR $f 0644]
}

foreach f {bras.tex bras.ps bras.pdf COPYING-2.0 \
	       recu-make-cons-harm.ps.gz} {
  lappend DOCTARGETS [file join $DOCDIR $f 0644]
}
lappend DOCTARGETS [file join $DOCDIR examples 0755]

set MANTARGETS [file join $MANDIR bras.1 0644]

set ALLTARGETS [concat $BINTARGETS $LIBTARGETS $DOCTARGETS $MANTARGETS]


searchpath {. doc}

########################################################################

## Delegate work to every target to be installed by means of the
## pattern rule for installation loaded above from install.rule
Make install {[updated $ALLTARGETS]} .relax.

## We need a target which merely fixes
## bras and bras.1 by entering some paths. This supports building of
## an rpm where the built is run with different paths than the
## install, which uses BUILD_ROOT.
Make all {[updated {bras.fixed bras.1.fixed}]} .relax.

## Here we create bras.fixed, a version of bras only used during
## installation. It will have $LIBDIR edited into the right place.
Newer bras.fixed {bras braspkg.tcl} {
  set out [open bras.fixed w]
  set skip 0
  forfile {line n} bras {
    if {$n==3} {
      puts $out "exec $TCLSH \"\$0\" \${1+\"\$@\"}"
      continue
    }
    switch -glob -- $line {
      "\#\#@(@*" {
	set skip 1
	continue 
      }
      "\#\#@)@*" {
	set skip 0
	cat braspkg.tcl $out
      }
      default {
	if {!$skip} {
	  puts $out $line
	}
      }
    }
  }
  close $out
}

Make braspkg.tcl {[older $target [SourcedFiles]]} {
  ## The exact info what has to be contained in braspkg.tcl is taken
  ## from bras
  set out [open $target w]
  set script {}
  append script\
      "\#\# file autogenerated during installation\n" \
      "\#\# if you edit it, your changes will be lost in\n"\
      "\#\# a future installation.\n"\
      "\n"\
      "\#\# USE:\n"\
      "\#\# To use this file, the directory [file dir $LIBDIR]\n"\
      "\#\# must be in your TCLLIBPATH environment variable\n"\
      "\#\# or explicitly added to auto_path. The you can load it\n"\
      "\#\# with\n"\
      "\#\#  package require bras $::bras::VERSION\n"\
      "\n"\
      "namespace eval ::bras {set base $LIBDIR}\n"
  puts $out $script
  foreach x $deps {
    cat $x $out
  }
  close $out
}

Always pkgIndex.tcl {} {
  append script \
      "\#\# tclPkgUnknown, when running this script, makes sure that\n"\
      "\#\# \$dir is set to the directory of this very file\n"\
      "package ifneeded bras $::bras::VERSION \\\n"\
      "\[concat source \[file join \$dir braspkg.tcl\] \\; " \
      "package provide bras $::bras::VERSION\]" 
  set out [open $target w]
  puts $out $script
  close $out
}

## Here we create bras.1.fixed to enter $DOCDIR into bras.1
Newer bras.1.fixed bras.1 {
  set out [open bras.1.fixed w]
  forfile line bras.1 {
    if {[string match *|DOC|* $line]} {
      regsub -all {\|DOC\|} $line $DOCDIR line
    } elseif {[string match *|VERDATE|* $line]} {
      regsub -all {\|VERDATE\|} $line $bras::VERDATE line
    } elseif {[string match *|VERSION|* $line]} {
      regsub -all {\|VERSION\|} $line $bras::VERSION line
    }
    puts $out $line
  }
  close $out
}
########################################################################
## find out which files are source by bras. Those make up braspkg.tcl.
proc SourcedFiles {} {
  set in [open bras]
  while {-1!=[gets $in line]} {
    if {[string match "\#\#@(@*" $line]} break
  }
  set script "set filelist {};"
  
  append script {
    namespace eval ::bras {set base [pwd]}
    proc source {name} {
      variable filelist
      lappend filelist $name
    }
  }
  while {-1!=[gets $in line]} {
    if {[string match "\#\#@)@*" $line]} break
    append script $line \n
  }
  close $in

  namespace eval ::install $script
  set filelist $::install::filelist
  namespace delete ::install
  #puts $filelist
  return $filelist
}
########################################################################
proc cat {file out} {
  set in [open $file]
  puts $out [read $in]
  close $in
}
########################################################################
proc forfile {varnames filename rexp {script {}} } {
  ## If script is empty, this in fact means rexp is empty and we use
  ## whatever we find in rexp as script.
  if {![string length $script]} {
    set script $rexp
    set rexp {}
    set all 1
  } else {
    set all 0
  }

  ## link varnames to caller's frame
  switch [llength $varnames] {
    1 #relax
    2 {
      upvar [lindex $varnames 1] lno
    }
    default {
      return -code error \
	  "first parameter may only have one or two elements"
    }
  }
  upvar [lindex $varnames 0] line


  ## open the file if this is not a file descriptor
  if {[catch {fconfigure $filename}]} {
    set in [open $filename r]
    set close {close $in}
  } else {
    set in $filename
    set close \#
  }

  set lno 0
  while {-1!=[gets $in line]} {
    incr lno
    ## skip unwanted lines
    if {!$all && ![eval regexp [list $rexp] [list $line]]} continue

    ## evaluate body 
    set code [catch {uplevel $script} result]

    ## treat return code of body
    # Copied from tcl.h as a reminder.
    # Why does catch not return the same codes as return does, at least
    # for those predifined codes?
    # define TCL_OK          0
    # define TCL_ERROR       1
    # define TCL_RETURN      2
    # define TCL_BREAK       3
    # define TCL_CONTINUE    4       

    switch -exact -- $code {
      0 {}
      1 {
	catch {eval $close}
	global errorInfo
	#puts "((($errorInfo)))[llength $errorInfo]"
	regsub "\n *\\(\"uplevel.*" $errorInfo {} errorInfo
	return -code error -errorinfo $errorInfo $result
      }
      2 {
	eval $close
	return -code return $result
      }
      3 break
      4 {}
    }
  }
  eval $close

  return {}
}


  