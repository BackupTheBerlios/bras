########################################################################
#
# This file is part of bras, a program similar to the (in)famous
# `make'-utitlity, written in Tcl.
#
# Copyright (C) 1996 Harald Kirsch, (kir@iitb.fhg.de)
#                    Fraunhofer Institut IITB
#                    Fraunhoferstr. 1
#                    76131 Karlsruhe
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
########################################################################


				 bras
			another kind of `make'
	       (C) 1996 Harald Kirsch (kir@iitb.fhg.de)


WHY THAT
========

This is `bras', another kind of `make' the basics of which I coded in
two days time after having the ideas in the back of my head for long.

I finally gave it a try because I dislike good old `make' for several
reasons. `Make'

  o has a crazy syntax,
  o has difficulties to handle dependencies in foreign directories,
  o does not distinguish between targets that merely need to exist and
    those that must be newer than other files, and
  o lacks control structures and pattern matching.

My idea was to combine the good ideas of `make', in particular the
rule based command execution, with all the niceties of a command
language. Since I personally like tcl (no flames, please), I ended up
with the present tcl-solution, however the same can probably be done
in other command languages.


HOW DOES IT WORK, AN OVERVIEW
=============================

A detailed doc is under way. The following notes probably expect a
bit of imagination from the reader ;-]

Bras defines the following new tcl-commands (formal parameters are
enclosed in <>):

    Exist <target> <commands>
    Newer <target> <dependencies> <commands>
    SuffixExist <.target> <commands>
    SuffixNewer <.target> <.dependencies> <commands>

Examples are:

1)   Exist /usr/local/holla {
      mkdir $target
    }

2)  Newer yummy.o {yummy.c yummy.h} {
      cc $CFLAGS -o $target $deps
    }

3)   SuffixNewer .a .o {
      ar r $target $newer
    }

4)   SuffixExist .xxx {
      touch $target
    }



The first one is probably most easily understood; and demonstrates a
feature the lack of which drives crazy with `make'. The rule declares
that `/usr/local/holla' must merely exist. Only if this is not the
case, the command is executed. Before execution of the command, the
variable `$target' will be replaced by `/usr/local/holla'.

The 2nd one is similar to the rules known to `make'. The associated
command is executed whenever one of the dependencies is newer than
`yummy.o' or if `yummy.o' does not exist.

The third example shows a suffix rule. Suffix rules are used if
  o a requested target has no explicit rule or
  o a requested target has an explicit rule with an empty command.

The forth example demonstrates a feature which I included mainly for
completeness. I must admit I did not yet come up with a useful
example. Rule (4) specifies that whenever there is nothing else said
about a target like `bla.xxx' then the command is executed.



When `bras' is run, it looks for the file `Brasfile' or `brasfile' and
expects it to be a tcl-script containing valid tcl-code. However it is
expected that it contains lots of the rule-commands described
above. The rules are recorded and after the whole file was read, the
main target --- which was specified on the command line or taken from the
first explicit rule --- is considered in a very similar fashion to
make. `Bras' recursively tracks targets with dependencies that need to
be remade and constructs a list of commands from the commands
specified in the rules. Finally the commands are executed.

The commands are executed on the global level, i.e. they have access to
global variables that were set when the brasfile was sourced
in. If a command isn't a tcl-command, bras, like tclsh, tries to
execute it as a program.


COMPATIBILITY
============

You may have guessed already that `bras' will not understand
makefiles. And it is not envisaged to teach it this skill. There is
however one exception. The command 

    sourceDeps <file>

expects <file> to be generated by `cc -M', i.e. it may contains plain
makefile-dependencies like
    
    this.o: this.c this.h that.h other.h whatever.h

They are converted to newer-rules without commands and will almost
exactly as with `make'. `SourceDeps' silently ignores it, if <file>
does not exist.


SPECIALTIES
===========

a) Dependencies in Foreign Directories

My favorite feature of `bras' are dependencies starting with
`@'. Consider the rule

    Exist all {@lib/all @doc/all} {
      ;# only a trigger
    }

Similar to the common practice in makefiles, `all' is not intended
here to ever become a file. It is merely a trigger for other
targets. It triggers `lib/all' and `doc/all'. Unlike `make', `bras'
knows quite well how to handle dependencies leading to other
directories, if they are marked with `@'. The `@' instructs `bras' to
change to the directory of the target, source the `brasfile' it finds
there, and derive all that is necessary to build the target from the
new information. In particular, all commands that need to be executed
on behalf of the target in that directory are executed there


b) Equivalents of make's special vars $@, $<, etc.

Just before the commands of a rule are evaluated, the variable
`target' is set to the name of the rule's target. Additionally, for
newer-rules, the variables `deps' and `newer' are set. `Deps' contains
all dependencies, while `newer' contains only those that are newer
than the target. If the target does not exist, all dependencies are
considered newer and `newer' is equal to deps.

REMARK: To prevent unwanted interference with tcl's command
evaluation, newline-characters are removed from the list of
dependencies.



RESTRICTIONS
============

a) GLOBBING FOR EXEC'ED COMMANDS
Since commands that are not tcsh-internal are executed with tcsh's
exec, in particular no globbing is performed on the command
line. Therefore are rule like

    Exist clean {
      rm *.o *.a *~
    }

does not work as expected. Currently you have to resort to something
like 

    Exist clean {
      eval rm [glob -nocomplain -- *.o *.a *~]
    }

The eval is necessary to let `rm' see a list of arguments and not just
one argument string consisting of all files globbed.

(I would appreciate any hint on how to avoid this problem.)


b) TARGET OR DEPENDENCIES WITH SEMICOLONS
To make a long story short: don't try. If you really need it, you are
on your own. Maybe a certain amount of backslash-quoting
helps. I did not yet try it myself.



c) SUBSTITUTION INTO EXTERNAL COMMANDS
Suppose you set CFLAGS to "-g -Wall" and have a command like

    cc $CFLAGS -c $target

If external commands were only exec'ed you couldn't expect this to
work, because it were equivalent to the tcl-script

    exec cc $CFLAGS -c $target

which calls `cc' with just 3 arguments, i.e. 

    cc "-g -Wall" -c whatever.c

To make it work, bras actually does

    eval exec cc $CFLAGS -c $target

but beware of unwanted flattening: The eval lets one level of braces
disappear so that

    sed -e {s/^[/]*//} bla >bli

after `eval' is called like

    exec -e s/^[ ]*// bla >bli

and tcl complains about the unknown command in `[/]'.



d) SOURCED SCRIPTS DON'T HAVE THEIR PRIVATE SCOPE
Since all brasfiles of subdirectories that are sourced in due to
`@'-dependencies evaluated at the same (the top-) level, you don't
have directory-local variables, except you invent new names. For
example having 

   set TOOL this_dirs_main_target
   Exist clean {
     rm $TOOL
   }

in every directory's brasfile dpes not work, because only one
definition of TOOL will survive, and a global `bras clean' will try to
delete the same `$TOOL' in every directory.

I want to change this the other day. Mayby [incr tcl] is a solution.





THE NAME OF THE GAME        (  <-*|:-]   )
====================

First I wanted to call it `brassel' which is the imperative of
`brasseln', a word you probably won't find in the dictionary. You may
need to ask someone from around Koeln to get the answer that (s)he
knows what it means but cannot explain it. Well, since `brassel' is
much to long for a good Un*x utility, I shortened it to `bras'.



