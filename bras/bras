#!/usr/local/bin/tclsh
set brasBase |SRCBASE|
set VERDATE 1111-11-11
########################################################################
#
# This file is part of bras, a program similar to the (in)famous
# `make'-utitlity, written in Tcl.
#
# Copyright (C) 1996 Harald Kirsch, (kir@iitb.fhg.de)
#                    Fraunhofer Institut IITB
#                    Fraunhoferstr. 1
#                    76131 Karlsruhe
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# $Revision: 1.10 $, $Date: 1997/04/30 17:35:27 $
########################################################################

########################################################################
##
## ---- global vars -----
##
## VERDATE
##   date of the version. This is not maintained by cvs, but is edited
##   into this file whenever I run my pack-script, so that it refers
##   to the whole package and not only to this particular file. Does
##   anybody know how this can be done with cvs?
##
## brasBase
##   Directory holding files sourced in by this script
##
## brasFile
##   Name of the rule file. Used also for rule-files in other dirs.
##
## brasCmd
##      array holding commands to execute to update targets. With
##      integer <i>, the following indices are used
##   <i>   -- the command itself
##   <i>,targ -- the list of targets which are updated by this command
##   <i>,preq -- list of prerequisites, i.e. of targets which must be
##               considered, before the command can be executed. And
##               it will only be executed, if all prerequisites are
##               reported to be ok or can be reconstructed.
##   nextID   -- next unique index to use
set brasCmd(nextID) 0
##
## brasTinfo
##      array holding information about targets. With <t> a target,
##      <d> its directory, the indices used are:
##   <t>,<d>,pred -- list of predicates, i.e. combinations of
##                   rule-names and dependencies. A typcial list
##                   element is s.th. like {Newer a b c}
##   <t>,<d>,cmd  -- index of command which updates this target
##   <t>,<d>,done -- set, if target was already considered.
##                   0: no need to make target
##                   1: target will be made
##                  -1: target needs to be made, but don't know how
##
## brasPrule
##   database of pattern-rules. Pattern rules are stored and accessed in
##   the same order as they are introduced. Therefore each one gets a
##   number. The indices are used as follows (<i> denotes an integer):
##   nextID     -- next unique index
##   <i>,target -- target
##   <i>,dep    -- all dependencies for given target
##   <i>,cmd    -- command for target/dependency pair
##   <i>,type   -- Newer, Exist, Always ...
set brasPrule(nextID) 0
##
## brasLastError
##   If it exists, it contains the deep reason, why the main target
##   cannot be made.
##
## brasKnown
##   array with an element for all dirs the rule-files of which have
##   already been sourced.
##
## brasTargets
##   Either the default target, i.e. the first one found, or the list
##   of targets from the command line
##
## brasOpts
##   array holding command-line options
##
## brasIncluded
##   array with an element for every file sourced in with
##   command `include'
##
## brasConsidering
##   array with an element for every target currently (recursively)
##   under consideration; used to detect dependency loops.
##
## brasCmdlist
##   list of commands to execute. Built up by bras.Consider. Howver,
##   only the topmost bras.Consider called finally sets the global
##   variable. All recursively called incarnations set the local
##   variable of their caller.
##
## brasIndent
##   string containing blanks, used for `-d'-reporting.
##
########################################################################

set argv0 [file tail $argv0]

## This if never succeeds after installation. I need it however run
## bras from my development directory.
if { "$brasBase"=="|SRCBASE|" } {
  set brasBase /home1/kir/work/bras
}
source $brasBase/evalCmds.tcl
source $brasBase/sourceDeps.tcl
source $brasBase/lastMinuteRule.tcl
source $brasBase/defaultCmd.tcl
source $brasBase/consider.tcl

## source rule types
source $brasBase/defrule.tcl
source $brasBase/alwaysRule.tcl
source $brasBase/commandRule.tcl
source $brasBase/existRule.tcl
source $brasBase/newerRule.tcl

########################################################################
##
## bras.gobble
##   a wrapper around `source $file' to handle errors gracefully
##
proc bras.gobble {file} {
  global errorInfo

  if [catch "uplevel #0 source $file" msg] {
    ## strip the last 5 lines off the error stack
    set ei [split $errorInfo \n]
    set l [llength $ei]
    set lastLine [lindex $ei [expr $l-6]]
    regsub {\".*\"} $lastLine "\"[pwd]/$file\"" lastLine
    puts stderr [join [lrange $ei 0 [expr $l-7]] \n]
    puts stderr $lastLine
    exit 1
  }
}
########################################################################
##
## include
##   an alias for `source', however we take care to not source any
##   file more than once.
##  
proc include {name} {
  global brasIncluded
  file stat $name stat

  if [info exist brasIncluded($stat(dev),$stat(ino))] return
  set brasIncluded($stat(dev),$stat(ino)) 1

  bras.gobble $name
}
########################################################################
##
## bras.PatternRule
##   Declare a pattern-rule.
##
proc bras.PatternRule {type target deps cmd} {
  global brasPrule argv0

  ## Emtpy commands are rather useless here
  if { ![llength $cmd] } {
    return -code error \
	-error "empty commands are not allowed in suffix rules"
  }

  ## make sure, no dependency is equal to the target
  foreach dep $deps {
    if { "$target"=="$dep" } {
      return -code error \
	  -errorinfo "target `$target' should not be equal to dependency"
    }
  }

  ## enter the rule
  set id $brasPrule(nextID)
  incr brasPrule(nextID)
  set brasPrule($id,target) $target
  set brasPrule($id,dep)    $deps
  set brasPrule($id,cmd)    $cmd
  set brasPrule($id,type)   $type

  ## create pattern replacement commands for all dependencies
  foreach d $deps {
    if { [llength [info commands Dep$d]] } continue
    proc Dep$d {target} "return \[file root \$target\]$d"
  }
}
########################################################################
##
## User command to add (more) dependencies to a target
##
if 0 {
proc Dependencies {target deps} {
  global brasTinfo brasFile brasKnown

  ## I wonder if it were better to squeeze out multiply mentioned
  ## dependencies.
  if {![info exist brasTinfo($target,[pwd],deps)]} {
    set brasTinfo($target,[pwd],deps) $deps
  } else {
    eval lappend brasTinfo($target,[pwd],deps) $deps
  }

  ## source rule-files for dependencies, if necessary. This is
  ## necessary only for dependencies starting with `@'. Most of the
  ## code below is error-checking.
  foreach x $deps {
    if ![string match @* $x] continue

    set dir [file dir [string range $x 1 end]]

    ## change to dir of that dependency
    set pwd [pwd]
    if [catch "cd $dir" msg] {
      set err "dependency `$x' leads to "
      append err "non-existing directory `$dir'"
      return -code error -errorinfo $err
    }
    #puts "+++ Just switched to [pwd]"

    ## source only, if we have not seen this directory's brasfile before
    if {[info exist brasKnown([pwd])]} {
      cd $pwd
      continue
    }

    if { ![file exists ${brasFile}]} {
      set err "dependency `$x' leads to"
      append err " `[pwd]', but there is no `${brasFile}'"
      cd $pwd
      return -code error -errorinfo $err
    }
    set brasKnown([pwd]) 1
    bras.gobble ${brasFile}
    cd $pwd
  }
}
}
########################################################################
##
## bras.enterRule
##    declare a rule
##
proc bras.enterRule {type targets deps cmd} {
  global brasCmd brasTinfo brasFile brasTargets brasKnown argv0

  #parray brasCmd
  ## newline characters and semicolons are poisonous for `eval' so
  ## they have no business being in `deps'. The foreach-loop was
  ## choosen to normalise list of dependencies by squeezing out
  ## unwanted whitespace.
  regsub -all ";" $deps {\\;} d
  set deps {}
  foreach x $d {lappend deps $x}

  ## it is wrong for any of the targets to have already a command
  ## associated with it, if this command is not empty
  if {"$cmd"!=""} {
    foreach t $targets {
      if {[info exist brasTinfo($t,[pwd],cmd)]} {
	set ci $brasTinfo($t,[pwd],cmd)
	set err "target `$t' has already command "
	append err ">>>>>$brasCmd($ci,cmd)<<<<<"
	return -code error -errorinfo $err
      }
    }
  }

  ## Enter the predicate to every target
  foreach t $targets {
    if {![info exist brasTinfo($t,[pwd],pred)]} {
      set brasTinfo($t,[pwd],pred) {}
    }
    lappend brasTinfo($t,[pwd],pred) "$type $deps"
  }

  ## Enter command, if any
  if {"$cmd"!=""} {
    set ci $brasCmd(nextID)
    set brasCmd($ci,cmd) $cmd
    set brasCmd($ci,preq) $deps
    set brasCmd($ci,targ) $targets
    foreach t $targets {
      set brasTinfo($t,[pwd],cmd) $ci
    }
    incr brasCmd(nextID)
  }

  ## if this is the very first explicit rule seen, and if no target was
  ## specified on the command line, this is the default target-list.
  if { ![info exist brasTargets] } {
    set brasTargets [lindex $targets 0]
  }

  ## source rule-files for dependencies, if necessary. This is
  ## necessary only for dependencies starting with `@'. Most of the
  ## code below is error-checking.
  foreach x $deps {
    if ![string match @* $x] continue

    set dir [file dir [string range $x 1 end]]

    ## change to dir of that dependency
    set pwd [pwd]
    if [catch "cd $dir" msg] {
      set err "dependency `$x' leads to "
      append err "non-existing directory `$dir'"
      return -code error -errorinfo $err
    }
    #puts "+++ Just switched to [pwd]"

    ## source only, if we have not seen this directory's brasfile before
    if {[info exist brasKnown([pwd])]} {
      cd $pwd
      continue
    }

    if { ![file exists ${brasFile}]} {
      set err "dependency `$x' leads to"
      append err " `[pwd]', but there is no `${brasFile}'"
      cd $pwd
      return -code error -errorinfo $err
    }
    set brasKnown([pwd]) 1
    bras.gobble ${brasFile}
    cd $pwd
  }

}
########################################################################
##
## debugging only!
##
proc bras.showCmds {cmds} {
  foreach x $cmds {
    puts "$x"
  }
}
########################################################################
proc usage {} {
  global argv0 VERDATE
  puts stderr \
      "usage: $argv0 \[-f brasfile\] \[-d\] \[-f\] \[-h\] \[-n\] \[-r\]\
 \[-v\] \[--\] \[target ...\]
construct files based on a rule-file
  brasfile - rule-file to use (defaults: Brasfile or brasfile)
        -d - execute nothing, show reasoning
        -n - don't execute external commands
        -r - don't read system standard rule file
        -v - show all command lists before they are executed
        -- - use the rest of the command-line as target list
             (necessary, if a target starts with `-')
    target - target to be rebuilt (default: the target of the first
             rule in brasfile)

This version was packed from an up-to-date cvs-repository on $VERDATE.
"
  exit 1
}
########################################################################
proc bras.main {argc args} {
  global argv0 brasFile brasTargets brasPrule brasOpts
  global brasKnown brasBase brasLastError
  global brasIndent brasCmdlist
  
  set brasOpts(-d) 0 
  set brasOpts(-n) 0
  set brasOpts(-r) 0
  set brasOpts(-v) 0
  for {set i 0} {$i<$argc } {} {
    set opt [lindex $args $i]
    incr i
    switch -glob -- $opt {
      -d {set brasOpts(-d) 1}
      -f {
	if {$i>=$argc } {
	  puts stderr "$argv0: missing file name after option `$opt'"
	  exit 1
	}
	set brasFile [lindex $args $i]
	incr i
      }
      -n {set brasOpts(-n) 1}
      -r {set brasOpts(-r) 1}
      -v {set brasOpts(-v) 1}
      -- {
	for {} {$i<$argc} {incr i} {
	  lappend brasTargets [lindex $args $i]
	}
      }
      -* usage
      default {
	lappend brasTargets $opt
      }
    }
  }

  if { ![info exists brasFile] } {
    if { [file exists brasfile] } {
      set brasFile brasfile
    } elseif { [file exists Brasfile] } {
      set brasFile Brasfile
    } else {
      puts stderr "$argv0: no brasfile found"
      exit 1
    }
  }

  if { !$brasOpts(-r) } {
    set sys $brasBase/rules.[exec uname -s]
    if ![file readable $sys] {
      puts stderr \
	  "bras: no system specific rules file, leaves me stupid!"
    } else {
      bras.gobble $sys
    }
  }

  if { [info exist brasFile] } {
    set brasKnown([pwd]) 1
    bras.gobble $brasFile
  }

  if ![info exist brasTargets] {
    puts -nonewline stderr "$argv0: no target given"
    if [info exist brasFile] {
      puts stderr ""
    } else {
      puts stderr " and no brasfile found"
    }
    exit 1
  }

  #parray brasRules
  #parray brasPrule
  foreach target $brasTargets {
    set brasIndent ""
    set brasCmdlist {}
    set r [bras.Consider $target]
    #bras.showCmds $brasCmdlist
    if $brasOpts(-d) continue
    if {$r==-1} {
      puts "bras: cannot make $target because$brasLastError"
      puts "      try to use -d to find out more"
      exit 1
    }
    if {![llength $brasCmdlist]} {
      puts "$argv0: nothing to be done for `$target'"
    } else {
      bras.evalCmds $brasCmdlist
    }
  } 
  
}
########################################################################

if { [catch "bras.main $argc $argv" result] } {
  puts $errorInfo
}

########################################################################

##### Local Variables: #
##### mode:tcl #
##### End: #
