#!/usr/local/bin/tclsh
set brasBase |SRCBASE|
set VERDATE 1111-11-11

########################################################################
#
# This file is part of bras, a program similar to the (in)famous
# `make'-utitlity, written in Tcl.
#
# Copyright (C) 1996 Harald Kirsch, (kir@iitb.fhg.de)
#                    Fraunhofer Institut IITB
#                    Fraunhoferstr. 1
#                    76131 Karlsruhe
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# $Revision: 1.14 $, $Date: 1997/11/05 21:36:46 $
########################################################################

########################################################################
##
## ---- global vars -----
##
## VERDATE
##   date of the version. This is not maintained by cvs, but is edited
##   into this file whenever I run my pack-script, so that it refers
##   to the whole package and not only to this particular file. Does
##   anybody know how this can be done with cvs?
##
## brasBase
##   Directory holding files sourced in by this script
##
## brasFile
##   Name of the rule file. Used also for rule-files in other dirs.
##
## brasRule
##     database of rules. With integer <i>, the indices are as follows
##   <i>,type -- rule type (i.e. Newer, Exist, ...)
##   <i>,targ -- targets
##   <i>,deps -- dependencies
##   <i>,cmd  -- command
##   <i>,preq -- prerequisites
##   <i>,run  --  1: command already on command list
##               -1: command cannot be run due to missing prerequisites
##                0: not yet checked
##
##   nextID   -- next unique index to use
set brasRule(nextID) 0
##
## brasTinfo
##      array holding information about targets. With <t> a target,
##      <d> its directory, the indices used are:
##   <t>,<d>,rule -- list of rules where the target is mentioned
##   <t>,<d>,done -- set, if target was already considered.
##                   0: no need to make target
##                   1: target will be made
##                  -1: target needs to be made, but don't know how
##
## brasPrule
##   database of pattern-rules. Pattern rules are stored and accessed in
##   the same order as they are introduced. Therefore each one gets a
##   number. The indices are used as follows (<i> denotes an integer):
##   nextID     -- next unique index
##   <i>,target -- target
##   <i>,dep    -- all dependencies for given target
##   <i>,cmd    -- command for target/dependency pair
##   <i>,type   -- Newer, Exist, Always ...
set brasPrule(nextID) 0
##
## brasLastError
##   If it exists, it contains the deep reason, why the main target
##   cannot be made.
##
## brasKnown
##   array with an element for all dirs the rule-files of which have
##   already been sourced.
##
## brasTargets
##   Either the default target, i.e. the first one found, or the list
##   of targets from the command line
##
## brasOpts
##   array holding command-line options
##
## brasIncluded
##   array with an element for every file sourced in with
##   command `include'
##
## brasConsidering
##   array with an element for every target currently (recursively)
##   under consideration; used to detect dependency loops.
##
## brasCmdlist
##   list of commands to execute. Built up by bras.Consider. Howver,
##   only the topmost bras.Consider called finally sets the global
##   variable. All recursively called incarnations set the local
##   variable of their caller.
##
## brasIndent
##   string containing blanks, used for `-d'-reporting.
##
## brasPreqSeparator
##   the string that separates real dependencies from prerequisites in
##   dependency lists of rules
set brasPreqSeparator //
##
##
########################################################################

set argv0 [file tail $argv0]

## This if never succeeds after installation. I need it however run
## bras from my development directory.
if { "$brasBase"=="|SRCBASE|" } {
  set brasBase /home1/kir/work/bras
}
source $brasBase/evalCmds.tcl
source $brasBase/sourceDeps.tcl
source $brasBase/lastMinuteRule.tcl
source $brasBase/defaultCmd.tcl
source $brasBase/consider.tcl

## source rule types
source $brasBase/defrule.tcl
source $brasBase/alwaysRule.tcl
source $brasBase/existRule.tcl
source $brasBase/newerRule.tcl

########################################################################
#
# tcl (as of 8.0b1 and previous) does execute a `cd .' thereby
# spoiling its cache for pwd. Since bras happens to execute quite some
# `cd .', calling pwd afterwards, I trick it myself.
#
rename cd _cd
proc cd {dir} {
  if {"$dir"=="."} return
  _cd $dir
}
########################################################################
##
## bras.gobble
##   a wrapper around `source $file' to handle errors gracefully
##
proc bras.gobble {file} {
  global errorInfo

  if [catch "uplevel #0 source $file" msg] {
    ## strip the last 5 lines off the error stack
    set ei [split $errorInfo \n]
    set l [llength $ei]
    set lastLine [lindex $ei [expr $l-6]]
    regsub {\".*\"} $lastLine "\"[pwd]/$file\"" lastLine
    puts stderr [join [lrange $ei 0 [expr $l-7]] \n]
    puts stderr $lastLine
    exit 1
  }
}
########################################################################
##
## include
##   an alias for `source', however we take care to not source any
##   file more than once.
##  
proc include {name} {
  global brasIncluded
  file stat $name stat

  if [info exist brasIncluded($stat(dev),$stat(ino))] return
  set brasIncluded($stat(dev),$stat(ino)) 1

  bras.gobble $name
}
########################################################################
##
## bras.followTarget
##  
## Handle all what is necessary to follow an @-target to its
## home. In particular:
## - change directory
## - read brasfile
## And do all this with the necessary error handling.  
##
## RETURN
##   The current directory (before cd) is returned.
##
proc bras.followTarget {target} {
  global brasFile brasKnown
  #puts "followTarget $target"

  set oldpwd [pwd]
  set dir [file dir [string range $target 1 end]]

  ## carefully change directory
  if [catch "cd $dir" msg] {
    set err "bras: dependency `$target' in `$oldpwd/${brasFile}'"
    append err " leads to non-existing directory `$dir'"
    puts stderr $err
    exit 1
  }

  ## check, if we know already the brasfile here
  if [info exist brasKnown([pwd])] {
    return $oldpwd
  }

  ## before really reading the file, mark the current dir as known,
  ## because the file to be read may lead back here again.
  set brasKnown([pwd]) 1

  ## If the brasfile does not exist, print a warning. There is no need
  ## to terminate immediately, because things might be handled by
  ## default rules.
  if ![file exists ${brasFile}] {
    puts stderr \
    "bras warning: no `${brasFile}' found in `[pwd]', so hold your breath"
  } else {
    bras.gobble ${brasFile}
  }
  return $oldpwd
}
########################################################################
##
## bras.PatternRule
##   Declare a pattern-rule.
##
proc bras.PatternRule {type target deps cmd} {
  global brasPrule argv0

  ## Emtpy commands are rather useless here
  if { ![llength $cmd] } {
    return -code error \
	-error "empty commands are not allowed in suffix rules"
  }

  ## make sure, no dependency is equal to the target
  foreach dep $deps {
    if { "$target"=="$dep" } {
      return -code error \
	  -errorinfo "target `$target' should not be equal to dependency"
    }
  }

  ## enter the rule
  set id $brasPrule(nextID)
  incr brasPrule(nextID)
  set brasPrule($id,target) $target
  set brasPrule($id,dep)    $deps
  set brasPrule($id,cmd)    $cmd
  set brasPrule($id,type)   $type

  ## create pattern replacement commands for all dependencies
  foreach d $deps {
    if { [llength [info commands Dep$d]] } continue
    proc Dep$d {target} "return \[file root \$target\]$d"
  }
}
########################################################################
##
## bras.enterRule
##    declare a rule
##
proc bras.enterRule {type targets deps cmd} {
  global brasRule brasTinfo brasFile brasTargets brasKnown argv0
  global brasPreqSeparator brasOpts

  #parray brasCmd
  ## newline characters and semicolons are poisonous for `eval' so
  ## they have no business being in `deps'. Then separate dependencies
  ## into real dependencies and prerequisites
  regsub -all ";" $deps {\\;} d
  set deps {}
  foreach x $d {
    if {"$x"=="$brasPreqSeparator"} {
      set preq {}
      continue
    }
    if {[info exist preq]} {
      lappend preq $x
    } else {
      lappend deps $x
    }
  }

  ## If preq is not set, make it equal to deps
  if {![info exist preq]} {
    set preq $deps
  }

  ## if this is the very first explicit rule seen, and if no target was
  ## specified on the command line, this is the default target-list.
  if { ![info exist brasTargets] } {
    set brasTargets [lindex $targets 0]
  }

  ## Enter the rule into the database
  set rid $brasRule(nextID)
  incr brasRule(nextID)
  set brasRule($rid,type) $type
  set brasRule($rid,targ) $targets
  set brasRule($rid,deps) $deps
  set brasRule($rid,cmd)  $cmd
  set brasRule($rid,preq) $preq
  set brasRule($rid,run)  0

  ## Append the rule's id to every target's rule list
  foreach t $targets {
    if {![info exist brasTinfo($t,[pwd],rule)]} {
      set brasTinfo($t,[pwd],rule) {}
    }
    lappend brasTinfo($t,[pwd],rule) $rid
  }

  ## source rule-files for dependencies and prerequisites if
  ## necessary. This is necessary only for dependencies starting with
  ## `@'. Most of the code below is error-checking.
  ## Since 1997-07-19, the code below is only executed if specifically
  ## requested with option -es (early sourcing).
  if {!$brasOpts(-es)} return

  foreach x "$deps $preq" {
    if ![string match @* $x] continue
    set backHere [bras.followTarget $x]
    cd $backHere
  }
}
########################################################################
##
## debugging only!
##
proc bras.showCmds {cmds} {
  foreach x $cmds {
    puts "$x"
  }
}
########################################################################
proc usage {} {
  global argv0 VERDATE
  puts stderr \
      "usage: $argv0 \[-f brasfile\] \[-d\] \[-h\] \[-n\] \[-r\]\
 \[-v\] \[-es\] \[--\] \[target ...\]
construct files based on a rule-file
  brasfile - rule-file to use (defaults: Brasfile or brasfile)
        -d - execute nothing, show reasoning
        -n - don't execute external commands
        -r - don't read system standard rule file
        -v - show all command lists before they are executed
       -es - early sourcing: read brasfiles of foreign directories as soon
             as a @-dependency is encountered.
        -- - use the rest of the command-line as target list
             (necessary, if a target starts with `-')
    target - target to be rebuilt (default: the target of the first
             rule in brasfile)

This version was packed from an up-to-date cvs-repository on $VERDATE.
"
  exit 1
}
########################################################################
proc bras.main {argc args} {
  global argv0 brasFile brasTargets brasPrule brasOpts
  global brasKnown brasBase brasLastError
  global brasIndent brasCmdlist
  
  set brasOpts(-d) 0 
  set brasOpts(-n) 0
  set brasOpts(-r) 0
  set brasOpts(-v) 0
  set brasOpts(-es) 0
  for {set i 0} {$i<$argc } {} {
    set opt [lindex $args $i]
    incr i
    switch -glob -- $opt {
      -d {set brasOpts(-d) 1}
      -f {
	if {$i>=$argc } {
	  puts stderr "$argv0: missing file name after option `$opt'"
	  exit 1
	}
	set brasFile [lindex $args $i]
	incr i
      }
      -n {set brasOpts(-n) 1}
      -r {set brasOpts(-r) 1}
      -v {set brasOpts(-v) 1}
      -es {set brasOpts(-es) 1}
      -- {
	for {} {$i<$argc} {incr i} {
	  lappend brasTargets [lindex $args $i]
	}
      }
      -* usage
      default {
	lappend brasTargets $opt
      }
    }
  }

  if { ![info exists brasFile] } {
    if { [file exists brasfile] } {
      set brasFile brasfile
    } elseif { [file exists Brasfile] } {
      set brasFile Brasfile
    } else {
      puts stderr "$argv0: no brasfile found"
      exit 1
    }
  }

  if { !$brasOpts(-r) } {
    set sys $brasBase/rules.[exec uname -s]
    if ![file readable $sys] {
      puts stderr \
	  "bras: no system specific rules file, leaves me stupid!"
    } else {
      bras.gobble $sys
    }
  }

  if { [info exist brasFile] } {
    set brasKnown([pwd]) 1
    bras.gobble $brasFile
  }

  if ![info exist brasTargets] {
    puts -nonewline stderr "$argv0: no target given"
    if [info exist brasFile] {
      puts stderr ""
    } else {
      puts stderr " and no brasfile found"
    }
    exit 1
  }

  #parray brasRules
  #parray brasPrule
  foreach target $brasTargets {
    set brasIndent ""
    set brasCmdlist {}
    set r [bras.Consider $target]
    #bras.showCmds $brasCmdlist
    if $brasOpts(-d) continue
    #global brasRule;parray brasRule
    if {$r==-1} {
      puts "bras: cannot make $target because$brasLastError"
      puts "      try to use -d to find out more"
      exit 1
    }
    if {![llength $brasCmdlist]} {
      puts "$argv0: nothing to be done for `$target'"
    } else {
      bras.evalCmds $brasCmdlist
    }
  } 
  
}
########################################################################

if { [catch "bras.main $argc $argv" result] } {
  puts $errorInfo
}
########################################################################

##### Local Variables: #
##### mode:tcl #
##### End: #
