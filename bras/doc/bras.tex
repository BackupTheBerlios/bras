\documentclass[12pt]{article}
%\usepackage{bookman}
\usepackage{a4}

%%%%%%%%%%%%%%%%%%%%%%%%
%
% $Revision: 1.20 $, $Date: 2000/03/05 12:37:49 $
%
%%%%%%%%%%%%%%%%%%%%%%%%


\title{\textsf{bras}\\
another kind of `make'\\
\small \copyright 1996,1997,1998,1999 Harald Kirsch}
\author{\relax
Harald Kirsch\\
kir@iitb.fhg.de}

\newcommand{\bras}{\texttt{bras}}
\newcommand{\Bras}{\texttt{Bras}}
\newcommand{\make}{\texttt{make}}
\newcommand{\brasfile}{\texttt{brasfile}}
\newcommand{\Brasfile}{\texttt{Brasfile}}

\parindent 0pt
\parskip 1ex
\overfullrule 3mm
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                           \begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\maketitle
\tableofcontents


%\neueinbauen: 
%  keine preqs mehr
%  dynamisch expandierte dependencies
%  neue Methode um Kommandos zu finden





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Why That?}
If you ever used \texttt{make}, you may have noticed that it has a few
odd features. Most annoying to me are

\begin{itemize}
\item 
the crazy syntax (tabs as a structuring element!),
\item 
the way variables are expanded (I never found out, when exactly
this happens),
\item 
the inability to call makefiles in other directories without
breaking the chain of reasoning,
\item 
the inability to distinguish between targets that merely need to
  exist, those that must be newer than their dependencies, and others
  which must be made for totally different reasons,
\item the inability to call the reasoning process explicitely without
  forking a new \make, thereby breaking the chain of reasoning,
\item 
the lack of control structures,
\item 
the lack of decent pattern matching, and
\end{itemize}

It is indisputable that \textbf{the} feature of \texttt{make} ---
rule based command execution --- is most helpful in many situations;
in particular were it seems to be applied most often:
conditional compilation of large programs.

My idea was to combine the key features of \texttt{make} with all the
niceties of a command language, while improving on the misfeatures
mentioned above. \Bras{} allows to define new types of
rules, so that a target can be rebuilt not only because it is out of
date, but because of any reason implemented in a new rule.\footnote{My
first idea was to have at least three types of rules, instead of the one
in \make{}, but someone on the net proposed to generalize the idea so
that new types of rules can be easily implemented.}

Since I personally like Tcl, not the least for its well defined
handling of command line substitution (see \texttt{Tcl(n)} and no
flames, please), I ended up with the present solution. A similar
solution might be possible with other command languages.

%The following sections assume that you have a rough idea what \make\
%is all about and what it does. Maybe I copy an introductory
%section from a \make\ manual here the other day, but until then
%\ldots.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction and Definition of Terms}
\label{SecDefTerms}

Unlike in shell-scripts or programming languages like C, Ada or Java,
the order of command execution in \brasfile{}s is not only described with
control-structures like if-then-else, loops, etc., but also with rules.
The main ingredients of a rule can be described along the following
example.

\begin{verbatim}
  Newer fft.o {fft.c fft.h} {
    cc -o fft.o fft.c
  }
\end{verbatim}

The file \texttt{fft.o} is called the \textit{target} of the rule. The
ultimate goal of writing a rule is to describe what has to be done
under certain conditions to bring the target up-to-date. The meaning
of up-to-date depends on the type of the rule (at least in
\bras{}). The example shows a \texttt{Newer}-rule, so
up-to-date means that the target \texttt{fft.o} is a file which must
be newer than the files \texttt{fft.c} and \texttt{fft.h}. Other
types of rules implement other meanings of up-to-date.

Usually the notion of the target being up-to-date depends on other
targets, which is why they are called \textit{dependencies} in this
context.\footnote{From Webster's entry \textit{dependency} I conclude
  that this is a misnomer. But it is well known in the context of
  \make{}, so I stick to it.} In the example, \texttt{fft.c} and
\texttt{fft.h} are the dependencies.  Dependencies can be understood
as parameters necessary to check whether the target is up-to-date or
not.

The next ingredient of a rule is the \textit{command} deemed suitable
to bring the target up-to-date with regard to the rule's particular
meaning of up-to-date. \Bras{} assumes that the target
is up-to-date as soon as it has executed the command without error. In
the example, the command specifies a call to the C compiler to compile
\texttt{fft.c} into \texttt{fft.o}.

%There is one additional ingredient to a rule which can be easily
%confused with the dependencies. While a dependency can render a target
%out-of-date, there might be files necessary to execute the rule's
%command, but which don't influence the target's being up-to-date.
%They are called \texttt{prerequisites}. As an example consider the
%following rule:

%\begin{verbatim}
%  Exist /usr/local/blarilu-2.17 {/usr/local} {
%    mkdir $target
%  }
%\end{verbatim}

%In an \texttt{Exist}-rule, the target is only out-of-date if it does
%not exist. The rule shown specifies that the \texttt{mkdir}-command
%must be executed whenever the target \texttt{/usr/local/blarilu-2.17} does
%not exist.  Because \texttt{/usr/local} is not a parameter of the
%up-to-date test for the target, it is a merely a prerequisite and not
%a dependency.

%The distinction between dependencies and prerequisites is rather
%academic most of the time, which I derive from the fact that \make{}
%is quite successful, although it totally ignores this distinction.
%\Bras{} on the other hand allows to explicitely specify prerequisites.
%Because an \texttt{Exist}-rule by definition has no dependencies,
%\texttt{/usr/local} is understood as a
%prerequisite. \texttt{Newer}-rules may have both, dependencies and
%prerequisites. They are separated by a double-slash (\texttt{//}), e.g.:

%\begin{verbatim}
%  Newer specialDigest {this that and other files // makeDigest} {
%    makeDigest $deps
%  }
%\end{verbatim}

%The double-slash, if present, marks the end of the dependency list.
%All names behind it are understood as mere prerequisites.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Standard Rules}
\label{SecStandardRules}
As mentioned in the previous section, \bras{} distinguishes between
different meanings of \textit{up-to-date}. While historic
\make{} has only one notion of up-to-date, i.e. the target must exist
and must be newer than its dependencies, \bras{} currently implements
the following meanings of up-to-date. Others can be added
easily.

\begin{itemize}
\item 
The \texttt{Newer}-rule most closely resembles \make's notion of
\textit{up-to-date}.
\item 
The \texttt{Exist}-rule considers a target to be up-to-date,
if a file of that name exists. The file's modification time is irrelevant.
\item 
The \texttt{Always}-rule considers the target to be never
up-to-date, i.e.\ the rule's commands are always executed if
\bras{} is asked to bring this target up-to-date.
\end{itemize}

Certainly someone can come up with an application requiring other
types of rules. How about a rule which rebuilts
the target only if \textbf{all} dependencies are newer than the
target, one that rebuilts if a dependency-file is longer than the
target-file, one which rebuilts only, if the moon is in a certain
phase, or $\ldots$ you name it?  Section~\ref{secNewRules} describes
how to implement new rules. For the moment however, only the
rule-types listed above are of interest.

The general form of a rule is
either
\begin{quote}
\textit{Rulename} \textit{targets} \textit{deps} \textit{command}
\end{quote}
or
\begin{quote}
\textit{Rulename} \textit{targets} \textit{command}
\end{quote}
depending on the rule type. \texttt{Always}- and \texttt{Exist}-rules
don't need dependencies.

The \textit{Rulename} is one of \texttt{Newer}, \texttt{Exist},
\texttt{Always}, or the name of an additionally implemented rule.

\paragraph{Targets:}
The list \textit{targets} contains one or more targets for the rule. A
rule with more than one target behaves very similar to a list of rules
which are identical except for the targets. However pooling the
targets into one rule tells \bras{} that execution of the rule's
command will update all the targets. Consequently the command
is executed only once, even if during the course of reasoning two or
more targets of the rule are found to be out-of-date.

\paragraph{Dependencies:}
The list \textit{deps} contains dependencies. Dependencies are
parameters used by the reasoning process when it checks if a target is
out-of-date. In a \texttt{Newer}-rule they normally denote files, but
in other types of rules they can be different things depending on the
implementation of the rule.

\paragraph{Command:}
The optional \texttt{command} is a Tcl-script to be executed if
\bras{} reckons that one or more of the rule's targets need to be
updated. If no command is given, it is defined to be emtpy. Empty
commands are replaced by default commands as explained in
section~\ref{secSuffixAsDefCmd}. 

A command is \textit{empty}, if it is exactly the empty string,
i.e. \verb+{}+ or \verb+""+. Using a string of some blanks on the
other hand is a way to specify a command which does nothing and may
not be replaced by a default command\footnote{Given that I flame
\make{} for using tabs as a syntactical element, this is probably not
the final solution. I might introduce an explicit do-nothing
command in later versions.}.

The following sections describe the available rule-types in detail.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Newer}-rule}
\label{secNewer}
The rule most familiar to \make-users is the
\texttt{Newer}-rule. It has the form:
\begin{quote}
  \texttt{Newer} \textit{targets} \textit{deps} \textit{command}
\end{quote}
An example is
\begin{verbatim}
  Newer yummy.o {yummy.c yummy.h} {
    cc $CFLAGS -o $target [lindex $deps 0]
  }
\end{verbatim}
For the meaning of \texttt{\$target} and \texttt{\$deps} see
section~\ref{secCmdExec}. If the rule is invoked for one of its
targets, the \textit{command} is executed whenever at least one of the
following conditions holds:
\begin{itemize}
\item No file of name \textit{target} exists in the current directory.
\item A file with name \textit{target} exists but is older than an
existing file contained in the dependency list \textbf{after} the
files of the dependency-list have been considered and possibly
updated.
\end{itemize}

If the target does not exist, the \texttt{Newer}-rule can immediately
decide that it must be rebuild --- without even looking at the
dependencies. But if it does not look at the dependencies, they might
not be correctly built before the rule's command is
executed. Therefore even if the target does not exist, all
dependencies are considered even before the target itself is
considered. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Exist}-rule}

The \texttt{Exist}-rule has the form
\begin{quote}
  \texttt{Exist} \textit{targets} \textit{command}
\end{quote}
and an example is
\begin{verbatim}
  Exist /usr/local/bras-0.1 {
    mkdir -p $target
  }
\end{verbatim}
If the rule is invoked, the \textit{command} is executed only if
there is no file (or directory) with that name.  It is an error to
specify dependencies for an \texttt{Exist}-rule.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Always}-rule}

The \texttt{Always}-rule has the form:

\begin{quote}
  \texttt{Always} \textit{targets} \textit{command}
\end{quote}

An example is
\begin{verbatim}
  Always clean {@lib/clean @src/clean @doc/clean} {
    puts "Oh, what a dirty job."
  }
\end{verbatim}

If the rule is invoked for one of its targets, the \textit{command} is
always executed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{The \texttt{DependsFile}-rule}
%\label{sec:DependsFile}

%The \texttt{DependsFile}-rule was invented to handle the dependency
%between C source files and the included header files. To understand
%why this is difficult, please note the following: An object file
%depends on its source file and on all the header-files it
%(recursively) includes. Fixing this list at some point in time in the
%depencency list of a \texttt{Newer}-rule will lose as soon as an
%additional file is included into the source.

%A correct approach would be to have a dynamic dependency list which is
%generated anew whenever the source file is considered. But generation
%of the list requires to read the source file and all (recursively)
%included header files --- exactly what all this rule-business tries to
%avoid.

%A better approach is to cache the dependency list in a special
%file. Whenever the source file or one of the files listed in the
%cache file is changed, the cache needs to be regenerated and the
%source must be compiled.

%The \texttt{DependsFile}-rule is used to manage the cache-file. Its
%general form is the same as for the other rules:
%\begin{quote}
%  \texttt{DependsFile} \textit{targets} \texttt{dependencies}
% \textit{command}
%\end{quote}

%It expects a target to be a file which contains file names. If the
%target does not exist, it is supposed to be out of date and triggers
%execution of the command. Otherwise, the target is read and whatever
%is found is appendend to the dependency list. The resulting pair 
%(target, dependency list) is than handled as if it were found in a
%\texttt{Newer}-rule. In fact, internally it is handed to the
%evaluator of \texttt{Newer}-rules.

%An example use is demonstrated below:

%\begin{verbatim}
%  Newer a.o a.dep {
%    compile a.c into a.o
%  }
%  DependsFile a.dep a.c {
%    extract names of included files from a.c 
%    and store the list in a.dep
%  }
%\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Multiple Rules for a Target}
\label{secMultipleRules}

It is not uncommon to have more than one rule for a target. In
particular when dependency relations are computed automatically, it is
not always possible to pool them into one rule. However two conditions
must be met by the set of rules mentioning a certain target:

\begin{enumerate}
\item they must be all of the same type and
\item at most one of them may have a (non-empty) command.
\end{enumerate}

An example is 
\begin{verbatim}
  Newer a.o {b.h a.h}
  Newer a.o a.c
  Newer a.o a.h
\end{verbatim}

Internally, \bras{} combines all rules for a target into a single
one. The dependencies of all the rules without a command are
concatenated in the order in which they appear. However every
dependency will be entered only once. In the above example, the result
is equivalent to: 
\begin{verbatim}
  Newer a.o {b.h a.h a.c}
\end{verbatim}

A special case is the single rule in the set which has a command, if
any. Its dependencies will always be in front of the whole dependency
list.  Automatically generated rules can then make use of
\texttt{[lindex \$deps 0]} or similar idioms to to access dependencies
in a defined way (cf.\ section~\ref{secPatRules}).

Example:
\begin{verbatim}
  Newer a.o {b.h a.h}
  Newer a.o a.c {
    cc -o $target -c [lindex $deps 0]
  }
\end{verbatim}
The dependency \texttt{a.c} of the last rule will be moved to the
start of \texttt{\$deps} so that \verb|[lindex $deps 0]| will be
\texttt{a.c}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Pattern Rules}
\label{secPatRules}

Pattern rules extend on the idea of \make's suffix or implicit
rules and serve two purposes:

\begin{enumerate}
\item 
If there is no rule for a target under consideration, \bras{}
tries to find a pattern rule and uses it to create a rule on
the fly. The matching process is described in
section~\ref{secSuffixToReal}.
\item 
If a rule with an empty command is triggered, \bras{} tries
to find a pattern rule to substitute its command as a default.
\end{enumerate}

Every rule type has its corresponding pattern rule type. 
For a rule with name \textit{Type} the pattern rule has the name
\texttt{Pattern}\textit{Type}. For the build-in rules the names are
\texttt{PatternNewer}, \texttt{PatternExist} and
\texttt{PatternAlways}.

The general form of pattern rules is
\begin{quote}
\texttt{Pattern}\textit{Type regexp deptag command}
\end{quote}

The individual elements of a pattern rule are described below:

\begin{description}
\item[\textit{Type}] 
  is \texttt{Newer}, \texttt{Exist},
  \texttt{Always}, or the name of an additionally
  implemented rule, 
\item[\textit{regexp}] 
  is a regular expression used to select the targets
  for which this rule will be used,
\item[\textit{deptag}]
  is a tag which is used to select functions called to aid the
  process of selecting the correct pattern rule. The meaning of the
  tag is described in the following sections.
\item[\textit{command}] 
  is the command to be used in a derived real
  rule or as a default command.
\end{description}

The details about \textit{regexp} and \textit{deptag} are described
in sections~\ref{secSuffixToReal} and~\ref{secSuffixAsDefCmd}.

An example pattern rule to make an object file from a C source file is:
\begin{verbatim}
  PatternNewer .*\.o .c {
    $CC -o $target -c $CFLAGS [lindex $deps 0]
  }
\end{verbatim}
Note that when the script is executed, \texttt{\$target}
will be set to the name of the target under consideration and
\texttt{\$deps} will be set to the list of its dependencies. The idiom
\texttt{[lindex \$deps 0]} is similar to \make's automatic variable
\texttt{\$<}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{How pattern rules are used to create real rules}
\label{secSuffixToReal}

As mentioned above, pattern rules are used to create a new rule if
there is no explicit rule available for the target under
consideration. 
For a given target, a pattern rule is selected as described
below.

All known pattern rules are checked in the opposite order in which
they were specified so that rules defined later override those defined earlier. A rule must pass two tests to be selected.

First, the given real target must match the pattern rule's regular
expression. To make sure that the whole word matches, regular
expressions of pattern rules get an implicit \verb+^+ and \texttt{\$}
prefixed and suffixed. Put another way: If \texttt{target} is the
variable containing the target under consideration and \texttt{rexp}
is the regular expression of a pattern rule, \bras{} executes an
equivalent of
\begin{verbatim}
    regexp "^$rexp\$" $target
\end{verbatim}
to check whether the pattern rule is a \textit{candidate} or not.

Suppose a candidate pattern rule is found for a target named
\texttt{bla.o}. If the rule is of a type which does not have
dependencies, e.g.\ like \texttt{PatternExist}, the rule is taken.
Otherwise it must survive the following test to be taken. The test is
a two-step operation. 

\begin{description}
\item[Step 1] derives a dependency from \texttt{bla.o}. It calls a
  procedure with a name derived from $deptag$ to create a dependency
  name:
  \begin{quote}
    \texttt{GenDep}$deptag$ \texttt{\$target}
  \end{quote}
  For example if \textit{deptag} is \texttt{.c}, \bras{} calls
  \begin{quote}
    \texttt{GenDep.c \$target}
  \end{quote}
  to derive a dependency name. The default
  \texttt{GenDep$deptag$} looks like
  \begin{quote}
    \verb|proc GenDep|$deptag$ \verb|{target} {|\\
      \texttt{\hspace*{2em}return [file root \$target]$deptag$}\\
      \verb|}|
  \end{quote}
  It strips the file extension from the target and suffixes the
  result with $deptag$. More elaborate procedures can be defined
  if needed. 
  
\item[Step 2] subjects the dependency name to \texttt{searchpath} (see
  sectinon~\ref{secSearchPath}). If it finds the dependency name as an
  existing file or if it finds a real rule for the dependency, it is
  taken.
\end{description}

If a dependency is taken, \bras{} creates a real rule with
\begin{itemize}
\item the target under consideration as the rule's target,
\item the derived dependency as the only dependency and
\item the command of the pattern rule as the rule's command.
\end{itemize}
It then proceeds as if there had never been a search for a pattern
rule.

If, after checking all pattern rules with the above tests, none is
selected, \bras{} tries one other thing. For each rule which matches
the target, a dependency is derived as described in step~1 above. Then
this is taken as a new target and \bras{} calls the above pattern-rule
selection recursively. It is made sure, that the recursion does not
loop infinitely by not trying any pattern-rule on different recursion
levels at the same time.

Ultimately, \bras{} will either run out of pattern-rules, in which
case it decides that there is no rule for the target, or it derives a
dependency which either exists as a file or has an explicit rule. All
intermediate pattern-rules are then converted to real rules and the
reasoning proceeds as if there were never any rules missing.

The algorithm is (should be :-) implemented in the file
\texttt{lastMinuteRule.tcl}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{How default commands are derived from pattern rules}
\label{secSuffixAsDefCmd}
Besides being rule patterns, pattern-rules are also used to define
default commands. The situation described in the last section is one
where there is \textbf{no} explicit rule for a certain target. In that
case a rule \textbf{and} a command are derived. 

This section describes the procedure taken if there is a rule for a
target, however without a command. A typical situation is described by
the following rules.

\begin{verbatim}
  Newer a.o b.h
  Newer a.o a.c
  Newer a.o a.h
\end{verbatim}

A single target, \texttt{a.o}, depends on several dependencies which
are spread over serveral rules. To find a command to create the
target, \bras{} also the pattern rules. Without taking into
account the dependencies already known, \bras{} uses almost the same
algorithm as described in section~\ref{secSuffixToReal} to find a
pattern rule for the target. The only difference is that the type of
the rule derived must match the type of the rule(s) already available
for the target, i.e.\ \texttt{Newer} in the example above. If a rule
is found, its dependency and its command are added the target's rule
as described in section~\ref{secMultipleRules}. In particular the
dependency resulting from the pattern rule is put in front of the
dependency list to make \texttt{[lindex \$deps 0]} work.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Rule Library}

Recently I started to collect a few generally useful pattern
rules. Look for files with suffix \texttt{.rule} in the
distribution. To access them in your brasfile, please use something
like 
\begin{verbatim}
  source [file join $::bras::base c2o.rule]
\end{verbatim}
Currently available are the following files:
\begin{center}
\begin{tabular}{l|l}
file name & functionality\\\hline
\texttt{c2.rule} & compile C source into object file\\
\texttt{cdeps.rule} & dependency maintenance for C source files\\
\texttt{cli2ch.rule} & generate command line parser with
  \texttt{clig}\\
\texttt{o2x.rule} & compile object file(s) into executable\\
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fine-tuning the Rule Base}
\begin{quote}\itshape
This section is not complete. It is not even written. The following
notes are only hints about what is possible. The described functions
are not very well tested and their interface might change in the
future.
\end{quote}

\begin{itemize}
\item
Every target has associated two lists: dependency list and command list.
\item
If more than one rule is given for a target, the lists are
concatenated. 
\item
The commands \texttt{ClearCmd}, \texttt{ClearDeps},
can be used to explicitely clear the respective
lists for a given target.
\item
The commands \texttt{GetCmd} and \texttt{GetDeps}
return the lists. Thus normal Tcl-commands can be
used to fiddle e.g.\ with the dependency list incrementally. This may
mainly be useful for automatic generation of rules.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dependencies in Other Directories}
\label{secForeignDeps}

Most annoying to me using \make{} is its unwieldy handling of
dependencies in other directories. Calling \make{} recursively after
changing to the foreign directory often breaks the chain of reasoning,
because there is no communication between parent- and child-make as to
whether any target was build or whether all targets were up-to-date.

\Bras{} allows a different solution. Whenever a dependency starts with
\texttt{@} and does not belong to the current directory, \bras{} expects
a \texttt{brasfile} in the directory where the dependency belongs
to. It uses the rules found there to reason about the dependency ---
if considered as a target. Lets look at an example:

\begin{verbatim}
  Newer bla {bla.o @../libfasel/libfasel.a} {
    $CC -c -o $target $CFLAGS $LDFLAGS $deps
  }
\end{verbatim}

Whenever the command \texttt{bras bla} is called, the rule is
considered, and consequently all dependencies in turn are considered
as a target. In particular \texttt{@../libfasel/libfasel.a} tells
\bras{} that there is a subdirectory \texttt{../libfasel} with a
\texttt{brasfile} which describes how to handle the target
\texttt{libfasel.a}.  \Bras{} reads \texttt{../libfasel/bras\-file}
and acts accordingly.  In particular \bras{} changes to directory
\texttt{../libfasel} before executing any command associated with a
rule in \texttt{../libfasel/brasfile}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Including Files Only Once}
\label{secInclude}

As described in section~\ref{secForeignDeps}, \bras{} automatically
sources the rule file in other directories if an \texttt{@}-dependency
leads there. But this mechanism is not very useful to source a file
with overall definitions. Instead, the Tcl-builtin command
\texttt{source} could be used, but it has the disadvantage that it
does not guard against sourcing the same file twice.

To make sure a file is sourced exactly once, use the
\texttt{include}-command. It takes as its only parameter the file to
read. 

Thats the simple truth, but consider the following setup. The main
directory of application \texttt{bla} has a \texttt{brasfile} and also
several subdirectories like \texttt{lib}, \texttt{extrabla},
\texttt{nobla}, etc. the targets of which are called from the main
\texttt{brasfile} by means of \texttt{@}. Now, what happens,
if you intend to solely work in directory \texttt{lib} for some time?
What is the best way within \texttt{bla/lib/brasfile} to get access to all
those general definitions in \texttt{bla/brasfile}?

Using \texttt{include ../brasfile} will not work, because all
rules of \texttt{bla/brasfile} would be interpreted relative to
\texttt{bla/lib}, which is usually wrong. The correct solution would
be:
\begin{verbatim}
  cd ..
  include brasfile
  cd bla
\end{verbatim}
Since this is tedious to type, you may use
\begin{verbatim}
  include @..
\end{verbatim}
which does the right thing.

In general, \texttt{include} has one argument which is either a
filename or is of the form \texttt{@}\textit{dir}, where \textit{dir}
is a directory name. In the latter cse, it looks for a \brasfile{} (or
\Brasfile{} or whatever was specified on the command line) and sources
the file in the context of the given directory.

Hint: If the included script needs to know its own name, use the
standard Tcl-command \texttt{[info script]}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Searching for Dependencies}
\label{secSearchPath}

In built-environments were source directories are read-only, compiled
files must be put into a different directory than source files. If in
addition builts for different platforms must be supported, source
files may be found in different directories depending on the platform
for which the built is performed.

One way to support that would be to create explicit rules in a loop
for all source files listed e.g. in variable \texttt{SRC}:
\begin{verbatim}
  foreach x $SRC {
    set base [file root $x]
    lappend OBJ build/$base.o
    Newer build/$base.o $platform/$base.c
  }
  Newer all $OBJ {}
\end{verbatim}

However this has at least two drawbacks:
\begin{enumerate}
\item The few lines above will become even more elaborate as soon as a
  source file may be either platform-specific or generic.
\item Pattern rules are no longer used because all rules are
  explicitely constructed.
\end{enumerate}

To overcome these drawback, the command \texttt{searchpath} was
introduced. With one argument it registers a list of pathnames which are
used to locate dependencies, e.g.
\begin{verbatim}
  searchpath {. ./generic ./unix}
\end{verbatim}
Whenever \bras{} looks at a dependency which is not an
\texttt{@}-dependency and which qualifies as
\begin{verbatim}
  [file pathtype ...]==relative
\end{verbatim}
it tries to find it along the search path. In particular it first
tries to find a file with that name along the search path. If it does
not find the file, it then
checks if there is an explicit rule for the name in one of the search
paths. The dependency found is then taken as the true dependency. If
no file or explicit rule can be found, the first directory in the
search path is assumed to be the correct one. Therefore the current
directory, i.e. a single dot, should almost always be the first
element in the list given to \texttt{searchpath}.

The search path declared with \texttt{searchpath} is always local for
the current directory, i.e. if \bras{} follows an \texttt{@}-target to
a different directory, this directory has its own search path.

To query the current search path, use \texttt{searchpath} without
arguments. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Use of Automatically Generated Dependencies}

\subsection{The Ancient Way}
Most C-compilers are able to generate makefile-dependencies for
source files by determining which files are included with
\texttt{\#include} directives. For example \texttt{gcc} can be
instructed to do so with option \texttt{-M} while SUN's Solaris
C-compiler uses \texttt{-xM}. Because this is a valuable feature,
\bras\ has the ability to read and understand a restricted type of
\make-dependencies. The command
\begin{quote}
  \texttt{sourcedeps} \textit{file}
\end{quote}
reads a dependency file created by the C-compiler and creates the
appropriate \texttt{Newer}-rules. The command prints a warning if
the given file does not exist.

\subsection{The Modern Way}
\label{secDepGen}
\begin{description}
\item[Q:] When does a C source file have to be compiled?
\item[A:] When either the file itself or at least one of the
  files which are directly or indirectly included was modified.
\end{description}
Consequently, the dependency list for an object file must contain the
C source file as well as all included files. Editing one of the files
of that list can result in the deletion or addition of an included
file, thereby changing the dependency structure itself and rendering
the dependency list out of date. Consequently, a static dependency
list which was written down or generated the other day will soon be
out of date if youd don't run \texttt{mkdepend} regularly. 

Instead of running it regularly, with a tool like \bras{} it should be
possible to update the dependency list as necessary. In fact, \bras{}
allows to generate dependency lists on the fly. Whenever \bras{} looks
at a dependency it tries to match it against a list of regular
expressions. If it finds a match, it calls a procecdure associated with
that regular expression and replaces the dependency with whatever the
procedure returns.

Pairs of regular expressions and procedures can be registered with the
command
\begin{quote}
  \texttt{Defdexpand} \textit{pname} \textit{rexp} \textit{targetname}
\textit{depname} \textit{script}
\end{quote}
An example is
\begin{verbatim}
  Defdexpand cdeps .*\.c target dep {
    ## do whatever is necessary to extract from $dep the true
    ## dependencies and return them
  }
\end{verbatim}
For the regular expression \verb|.*\.c| it registers the procedure
\texttt{cdeps} and defines it by calling
\begin{verbatim}
  proc cdeps {target dep} {
    ## do whatever is necessary to extract from $dep the true
    ## dependencies and return them
  }
\end{verbatim}
When a dependency is found which matches \verb|.*\.c|, the procedure
is called with the dependency as the second argument and the target
under consideration as the first.  Usually \texttt{cdeps} would run
\texttt{mkdepend} or something similar to find the dependencies of
\texttt{\$dep} and return them. In particular, \texttt{cdeps} may
maintain a cache of the dependency list which is updated only if
necessary. It may do so by explicitely invoking the reaoning process
by calling \texttt{consider} (see section~\ref{secConsider}).

It is worth to note that this type of expansion is run \textbf{after}
the search path was applied to a dependency. However, the resulting
dependencies are not again subject to search path expansion because
the dependency generator (e.g.\ \texttt{cdeps}) is expected to deliver
complete paths.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Explicitely Calling the Reasoning Process}
\label{secConsider}

Normally the reasoning process is invoked automagically for the first
target found in the \brasfile{} or for the targets mentioned on the
command line. However, sometimes it might be necessary to call it
explicitely, in particular within a rule's script. In a
\texttt{makefile} \make{} is \texttt{exec}ed recursively in such
situations. The disadvantage of this approach is, that results of
the reasoning which was already performed by the parent process are not
available to the child process. Consequently the child starts all over
again. \Bras{} allows to call the reasoning process explicitely
without \texttt{exec}. Just call

\begin{quote}
  \texttt{consider} \textit{target}
\end{quote}

to let \bras{} consider and update the given target. The result of
consider is -1, 0 or 1, depending on whether the target could not be
updated, did not need to be updated or was updated successfully.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using Environment Variables}
One of the nicer features of \make\ is its ability to override
variable values in the makefile with values from the command line or
from the environment with \texttt{var=value} or \texttt{-e}
on the command line respectively. 

A similar feature exists in \bras. To set a variable in a way that it
can be overridden by the environment or on the command line, use
\texttt{getenv} instead of \texttt{set} in your brasfiles. Example:
\begin{verbatim}
  getenv prefix /usr/local
\end{verbatim}
This will either set \texttt{prefix} to \texttt{\$env(prefix)} or, if
the latter does not exist, to \texttt{/usr/local}. If you require an
environment variable to be set, leave out the default as in
\begin{verbatim}
  getenv BLA
\end{verbatim}
If there is no variable with name
\texttt{BLA} in the environment, this will result in a Tcl-error.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{How \Bras Executes}

There are the following major phases of operation performed strictly in
sequence.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Set \texttt{env}-entries from the Command Line}
\label{secEnv}
All definitions like \texttt{var=value} found on the command
line are entered into the global array \texttt{env} thereby
overriding the respective values from the environment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Read Default Rule Files}
%If not suppressed with option \texttt{-r}, a default rule file is read
%to create default pattern rules and to set reasonable defaults to some
%global variables like \texttt{CC}, etc. Of course these defaults do
%not override any values found in the environment or on the command line.

%\begin{quote}\itshape
%  The rule files delivered with the current installation are no more
%  than a proof of concept and far from actually usable. Input welcome.
%\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Read \texttt{brasfile}}

The \texttt{brasfile} is read and executed. Here \textit{execution}
denotes execution in the sense of Tcl. Every rule is actually a
Tcl-\texttt{proc} which \textbf{only records} the rule in an internal
database. In particular, no command specified in a rule is executed.

But rules are not always totally passive in the first phase.  If
called with option \texttt{-es} (for \textbf{e}arly
\textbf{s}ourcing), the following happens.  If a dependency starts
with \texttt{@}, \bras{} temporarily changes to the directory of the
dependency and sources the \texttt{brasfile} it finds there. It
reports an error, if there is no \texttt{brasfile} with the same name
as the primary \texttt{brasfile}. Even if several dependencies of
different rules lead to the same directory, the \texttt{brasfile} is
sourced only once.

Option \texttt{-es} is mainly available for historic reasons. Without
it, \bras{} reads \texttt{brasfile}s in other directories on demand
during the reasoning process (section~\ref{secReasoning}). If you want
to force inclusion of a \texttt{brasfile} in a certain directory, use
\texttt{include} (section~\ref{secInclude}) with a parameter starting
with \texttt{@}.

Beside rules, any Tcl-command can be used in a \texttt{brasfile}. They
are executed as in every other Tcl-script. Useful examples are setting
global variables or \texttt{if}-statements including or excluding
system-specific rules.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reasoning Process}
\label{secReasoning}
Either the targets given on the command line or the targets of the
very first rule found in \texttt{brasfile} are considered in
turn. Considering a target can have three different results. 
\begin{enumerate}
\item
The target is up-to-date.
\item
The target is not up-to-date but there is a way to built it.
\item
The target is not up-to-date, but something necessary for building it
is missing and cannot be build.
\end{enumerate}
Checking a target is a recursive process. It requires consideration of
the target's dependencies. The exact order and interpretation of
recursive calls of the reasoning process are described
below.\footnote{The most precise description of what \bras{} does is
  in the source file \texttt{consider.tcl}. I do my best to match it
  as close as possible.}

$\bullet$ If the target starts with the character \texttt{@}, \bras{}
changes to the directory of the target and reads the \texttt{brasfile}
found there. Any directory part is removed from the targets name.

$\bullet$ If the target was considered already along another line of
reasoning, it is not checked again. Instead the result computed before
is immediately returned.

$\bullet$ If no rule is applicable for the target, \bras{} tries to
make one up as desribed in section~\ref{secSuffixToReal}. If none can be
constructed, the reasoning process returns immediately with one of two
results: If the target denotes an existing file, it reports that the
target is up-to-date. Otherwise it reports that the target is not
up-to-date and cannot be built.

$\bullet$ If there are rules for the target, none of which specifies a
command to update the target, a command is constructed as described in
section~\ref{secSuffixAsDefCmd}. If no command can be made \bras{}
merely prints a warning later, if it is decided that the target needs
an update.

$\bullet$ If a rule was created automatically for the target, its
dependencies have already been looked up along the search path
(section~\ref{secSearchPath}). But explicit dependencies are now
looked up along the search path. All dependencies are then subject to
dependency generation (section~\ref{secDepGen}).

$\bullet$ All resulting dependencies are considered in turn. If one
needs an update but cannot be made, the reasoning process immediately
returns to its caller.

$\bullet$ Finally, the rule is called with the target name and with
the list of dependencies and with the results of considering those
dependencies. It is then up to the rule to decide if the target needs
an update. If so, the rule's command is invoked. Details on how this is
done can be found in section~\ref{secCmdExec}.

Versions of \bras{} up to and including 0.6.0 merely recorded the
command on a list. Only after all reasoning was done was this list
executed. Newer versions immediately execute the command.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Command Execution}
\label{secCmdExec}

All commands derived from rules are executed in a private namespace
with a meaningless name (i.e.\ the name is automatically
generated). Consequently they have access to all global variables. In
addition the namespace contains the following variables set up for
each command.

\begin{description}
\item[\texttt{targets}] 
contains the list of targets for that rule,

\item[\texttt{target}] 
is the name of the target for which the rule
was invoked,

\item[\texttt{deps}] 
is the list of the rule's dependencies (note that \texttt{[lindex
  \$deps 0]} is mostly equivalent to \make's variable \texttt{\$<}),

\item[\texttt{trigger}]
contains those elements of \texttt{deps} which rendered the target
out-of-date. The contents of this variable depend on the type of
rule. For a \texttt{Newer}-rule it contains all dependencies which are
newer than the target, and all dependencies, if the target does not
exist. \texttt{Exist}- and \texttt{Always}-rules don't have
dependencies and the list will be empty. For additionally implemented
rules, the documentation of that rule must specify what it puts into
\texttt{trigger}. 
\end{description}

After setting these variables and changing to the right directory, a
rule's command list is executed. Non-internal commands are
automatically passed to \texttt{exec}. But please remember that
\bras{} is basically Tcl and unlike \texttt{sh}, it does no globbing
on the command line. Consequently, the rule
\begin{verbatim}
    Always clean {} {
      rm -f *.o *.a *~
    }
\end{verbatim}
does not work as expected. You have to resort to
\begin{verbatim}
   Always clean {}
      rm -f [glob -nocomplain -- *.o *.a *~]
    }
\end{verbatim}
    
A delicate problem is variable substitution in
external commands. Suppose \texttt{CFLAGS} is set to 
\texttt{"-g -Wall"} and there is a command like 

\begin{verbatim}
    cc $CFLAGS -c [lindex $deps 0]
\end{verbatim}

If external commands were only \texttt{exec}'ed you could \textbf{not}
expect this to work, because it were equivalent to the tcl-script

\begin{verbatim}
    exec cc $CFLAGS -c [lindex $deps 0]
\end{verbatim}

which calls \texttt{cc} with just 3 arguments resulting effectively in

\begin{verbatim}
    cc "-g -Wall" -c whatever.c
\end{verbatim}

To make it work, \bras{} actually does

\begin{verbatim}
    eval exec cc $CFLAGS -c $target
\end{verbatim}

but beware of unwanted flattening in commands containing braces: Due
to \texttt{eval} one level of braces
disappears and

\begin{verbatim}
    sed -e {s/^[/]*//} bla >bli
\end{verbatim}

is flattened by \texttt{eval} to

\begin{verbatim}
    exec sed -e s/^[/]*// bla >bli
\end{verbatim}

resulting in complaints about the unknown command in
\texttt{[/]}. The remedy is an extra level of braces.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing New Types of Rules}
\label{secNewRules}
As mentioned previously, there are situations where the standard
rule-types are not sufficient to describe the necessary reasoning.
New rule-types can be implemented
with \bras{}. \Bras{} has a procedure called \texttt{Defrule} to
define new rule types. It is used similar to Tcl's \texttt{proc}.

The use of \texttt{Defrule} is probably most easily described along a
running example. A hypothetical \texttt{Longer}-rule will be used
which asserts that the target file is longer (i.e. contains more
bytes) than the dependencies.

\begin{verbatim}
  Defrule Longer {rid target _reason depInfo} {
    upvar $_reason reason
    ...
  }
\end{verbatim}

The first paremeter of \texttt{Defrule} is the name of the rule.
\texttt{Defrule} installs a Tcl-\texttt{proc} called
\texttt{Check.Longer} which is called by the reasoning process to
check whether a target is out of date according to the rule. A
rule-type may have either three or four parameters. The names of these
parameters are given in the second argument to \texttt{Defrule}. Their
meaning is described below.

\begin{description}
\item[\texttt{rid}] is an internal rule identifier denoting the rule under
  consideration. It must eventually be used by the rule's body to call
  \texttt{::bras::invokeCmd}, the command to run the script associated
  with this rule.

\item[\texttt{target}] is the target for which the check has to be
  performed.

\item[\texttt{reason}] is an output variable. The rule must set it to
  descriptive text explaining why the target is out-of-date. It is
  printed by the reasoning process if \bras{} was called with option
  \texttt{-d}. The output is best formatted, if \texttt{reason}
  contains short lines of text \textbf{preceeded} by a newline
  character and without leading whitespace.
  
\item[\texttt{depInfo}] is only used for four-parameter rule types. When
  called by the reasoning process, it contains information about
  dependencies. The list has an even number of elements. The
  first of two elements is always the name of a dependency and the
  second is the result of the reasoning process for that dependency,
  i.e.\ either \texttt{1}, if the dependency was just built and
  \texttt{0}, if it was up-to-date. Obviously, rules like
  \texttt{Exist} are never interested in dependencies and consequently
  don't have this parameter.
\end{description}

The third argument to \texttt{DefRule} is the body of
\texttt{Check.Longer}. It uses the three or four parameters to
communicate with the resoning process. The body of the new rule-type
may contain any Tcl-commands. If the rule decides that the target must
be made, it must call \texttt{::bras::invokeCmd} with the following
arguments:

\begin{enumerate}
\item \texttt{\$rid} is the rule identifier which was passed into the
  rule's body.
\item \texttt{\$target} is the target which was passed into the
  rule's body.
\item The list of all dependencies, i.e.\ \texttt{\$depInfo} without
  the interspersed reasoning results.
\item A sublist of the dependencies holding those dependencies
  which are particularly responsible for the target being
  out-of-date. In the example of the \texttt{Longer}-rule the list
  would contain those dependencies which are longer than the target.
\end{enumerate}

The rule must return one of the following values:
\begin{description}
\item[-1], if the target can not be made for some reason,
\item[0], if the target is already up-to-date,
\item[1], if the target was successfully rebuilt.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Limitations and Known Bugs}


\begin{enumerate}
\item
Since I did not yet test \bras\ with a really big project like say
\texttt{Xemacs} or \texttt{Tcl/Tk}, I don't know if the recursive
inclusion of many \texttt{brasfile}s will lead to performance
problems.

\item
When sourcing \texttt{brasfile}s from other directories, \bras{}
currently does not construct a local scope for the variables used
there. The effect is that it is not possible to use the same variable
name, e.g.\ \texttt{SRC} and \texttt{OBJ}, in the brasfiles
of all subdirectories. This may be corrected in the future.

A workaround is to use in every \texttt{brasfile} an array with a name
patterned after the directory to store variables.

\item 
Parallel execution of several commands (as gnu make's option
\texttt{-j}) is not yet supported.

\item
A hack to translate \texttt{makefile}s to \texttt{brasfile}s is not
yet available.

\item
As normal in Tcl, parameters of \texttt{exec} are not passed through
\texttt{glob}, which may lead to surprising error messages about
non-existing files like \texttt{*.o}.

\item
The rule-files containing default pattern-rules are not very
elaborate, in fact the are next to useless.

\item
Although Tcl is a portable platform, \bras{} still contains a few
*nixisms.


\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Name of the Game}

First I wanted to call it \texttt{brassel} which is the imperative of
\texttt{brasseln}, a verb you probably won't find in the
dictionary. You may need to ask someone from around K\"oln, but be
prepared to get the answer that (s)he knows what it means but cannot
explain it. I think the description "`working concentrated, busily but
without stress"' is quite close to the real meaning.

Well, since \texttt{brassel} is much to long for a good
Un*x utility, I shortened it to \bras. It rhymes on the german word
\textit{Fa\ss}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Credits}

Some people helped to push \bras{} into the right direction. I
would like to thank them. 

\begin{itemize}
\item \texttt{nemo@gsyc.inf.uc3m.es} (Fco. J. Ballesteros) after
looking at a very early version had the
idea to allow the definition of new types of rules.

\item Jason Gunthorpe \texttt{<jgg@debian.org>} started
experiments to get rid of the \texttt{make/automake}-combination with
\bras{}. The resulting long discussions resulted in several changes
and enhancements of \bras{}. In particular commands to fine-tune the
rule-base were added, the semantics of pattern-rules was revised and
the \texttt{DependsFile}-rule was born.

\item Paul Duffin \texttt{<pduffin@hursley.ibm.com>} insisted in the
  usefulnes of a search path for dependencies.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\appendix

\section{Quick Reference Guide}
\newcommand{\Tt}[1]{\texttt{#1}}
\newcommand{\It}[1]{\textit{#1}}
\newcommand{\Flash}[1]{\fbox{\bfseries #1}}
\newcommand{\Sflabel}[1]{%
  \parbox[b]{\labelwidth}{%
    \makebox[1pt][l]{\textsf{\bfseries#1:}}\\\strut}}
  
\newenvironment{Describe}
{\vskip0pt plus2cm\begin{list}{}{\renewcommand{\makelabel}{\Sflabel}}}
{\end{list}\pagebreak[2]}

%%%%%
%%%%% Always
%%%%%
\begin{Describe}
\item[Name] \Flash{Always} --- always make a target
\item[Synopsis] \Tt{Always} \It{targets} \It{deps} \It{script}
\item[Description] The command registers a new \texttt{Always}-rule in
  the rule base. If later one of the targets is considered, it is always
  rebuild by executing the script. Nevertheless, all dependencies are
  considered in turn, before the script is run.
\item[Example]
In the following example, the use of \texttt{@}-targets delegates the
cleaning to \brasfile{}s in the given subdirectories. Afterwards the
current directory is cleaned.
\begin{verbatim}
Always clean {@lib/clean @prog1/clean @prog2/clean} {
  rm -f all what is left in the current dir
}
\end{verbatim}
\end{Describe}

%%%%%
%%%%% consider
%%%%%
\begin{Describe}
\item[Name] \Flash{consider} --- explicitely call the reasoning
  process 
\item[Synopsis] \Tt{consider} \Tt{target} \ldots
\item[Description] The command calls the reasoning process
  explicitely for the given target. In most cases, the reasoning
  process is only called explicitely for a given target by specifying
  it on the \bras-commandline. All other invocations happen
  automatically by recursively considering dependencies of targets
  under consideration. However, just in case the need arises, here is
  the command to invoke the reasoning process.
\item[Example] A truly useful example were the need arises to call
  \Tt{consider} is the maintenance of dependency caches as shown in
  the distribution file \texttt{cdeps.rule}.
\end{Describe}

%%%%%
%%%%% Defrule
%%%%%
\begin{Describe}
\item[Name] \Flash{Defrule} --- create new types of rules
\item[Synopsis] \Tt{Defrule} \It{type} \Tt{\{rid target \_reason
    deps\}} \It{script}\\ 
  \Tt{Defrule} \It{type} \Tt{\{rid target \_reason\}} \It{script}\\
\item[Description] The command creates new types of rules. It
  creates for the given type 
  \begin{itemize}
  \item a function (like \Tt{Always}) to register a new rule, 
  \item a function (like \Tt{PatternAlways}) to register a new
    pattern rule and
  \item a function which is called by the reasoning process to
    decide if a given target is up-to-date. The given parameter list
    and the script in fact make up this function.
  \end{itemize}
  Please read section~\ref{secNewRules} for a more elaborate
  description of \Tt{Defrule}
\item[Example] An example of how to use \Tt{Defrule} can be found
  in the file \Tt{newerRule.tcl} of the distribution.
\end{Describe}

%%%%%
%%%%% Exist
%%%%%
\begin{Describe}
\item[Name] \Flash{Exist} --- make sure that a target exists
\item[Synopsis] \Tt{Exist} \It{targets} \It{script}
\item[Description] The command registers a new \texttt{Exist}-rule in
  the rule base. If later one of the targets is considered, it is
  rebuild by executing the script if and only if it does not exist. In
  contrast to other types of rules, the \Tt{Exist}-rule does not have
  dependencies.
\item[Example]
\begin{verbatim}
Exist /usr/local/bras-1.0.0 {
  mkdir -p $target
}
\end{verbatim}
\end{Describe}


%%%%%
%%%%% getenv
%%%%%
\begin{Describe}
\item[Name] \Flash{getenv} --- copy from \texttt{env} into a variable
  or set the variable to a default value
\item[Synopsis] \Tt{getenv} \It{name} ?\It{default}?
\item[Description] The command copies the element of \Tt{env} with
  the given name into a variable of the same name. If the optional
  default value is not given and an element of the given name does not
  exist in \Tt{env}, an error message is printed and \bras{} exits. If
  a default value is given, it is taken instead of the missing entry
  in \texttt{env}. 
\item[Example] A typical use of \Tt{getenv} is to set compiler
  switches like \Tt{CFLAGS}:
\begin{verbatim}
getenv CFLAGS {-W -Wall -g}
\end{verbatim}

Please note that \bras{} allows to set elements of \Tt{env} on the
command line (see section~\ref{secEnv}), so the above default can be
overridden by calling \bras{} like
\begin{verbatim}
/home/bobo> bras CFLAGS='-O2 -W -Wall'
\end{verbatim}
\end{Describe}


%%%%%
%%%%% include
%%%%%
\begin{Describe}
\item[Name] \Flash{include} --- source a specified file or the
  \brasfile{} of a given directory, but only once
\item[Synopsis] \Tt{include} \It{file}\\
  \Tt{include} \Tt{@}\It{dir}
\item[Description] Basically, \Tt{include} is an alias for source
  which makes sure, no file is read more than once. 
  
  If the paramter is the name of a directory prefixed with \Tt{@}, the
  \brasfile{} of the given directory is sourced in the same way as if
  \bras{} had followed an \Tt{@}-target to that directory. The name of
  the \brasfile{} used depends on the name of the file where this
  command is found in. In particular, if \bras{} was called with
  option \Tt{-f} specifying a special name, that name is also used in
  the destination directory.
\item[Example]
  The form
  \begin{verbatim}
  include @..
  \end{verbatim}
  is most often used in \brasfile{}s of subdirectories to include a
  standard rule file of the parent directory. It allows to call
  \bras{} in the subdirectory alone and still having all global
  definitions of \Tt{../brasfile}.
\end{Describe}


%%%%%
%%%%% Newer
%%%%%
%\paragraph{Newer Rule}
\begin{Describe}
\item[Name] \Flash{Newer} --- make a target newer than its dependencies
\item[Synopsis] \Tt{Newer} \It{targets} \It{deps} \It{script}
\item[Description] The command registers a new \texttt{Newer}-rule in
  the rule base. If later one of the given targets is considered, it
  is rebuild by executing the script, if it does not exist or if it is
  older than at least one of the dependencies. Before the time stamps
  are tested, all dependencies are recursively considered and
  potentially created.
\item[Example]
\begin{verbatim}
Newer x.o x.c {
  cc -c -o $target [lindex $deps 0]
}
\end{verbatim}
\end{Describe}

%%%%%
%%%%% PatternXXX
%%%%%
\begin{Describe}
\item[Name] \Flash{Pattern\It{Type}} --- register a pattern rule for rule
  type \It{Type}
\item[Synopsis] \Tt{Pattern}\It{Type} \It{rexp} \It{tag} \It{script}
\item[Description] The command registers a pattern rule with the rule
  base. \It{Type} may be any of \Tt{Always}, \Tt{Exist}, \Tt{Newer} or
  the name of any other rule type which was created with \Tt{Defrule}.

  Whenever \bras{} considers a target for which no explicit rule
  was given, it tries to find a pattern with a matching \It{rexp} and
  might ultimately construct an explicit rule for the target. The
  details of the rule construction are described in
  section~\ref{secPatRules}. 
\item[Example] The file \Tt{c2o.rule} of the distribution contains the
  following example which takes care of making an object file from a C
  source file.
\begin{verbatim}
getenv CC cc
getenv CFLAGS {}
PatternNewer {.*\.o} .c {
  $CC -o $target -c $CFLAGS [lindex $deps 0]
}
\end{verbatim}
\end{Describe}

%%%%%
%%%%% searchpath
%%%%%
\begin{Describe}
\item[Name] \Flash{searchpath} --- set or get the search path for the
  current directory
\item[Synopsis] \Tt{searchpath} ?\It{new\_path}?
\item[Description] Without an argument, the search path set for the
  current directory is returned. If none is set, the empty string is
  returned. If an argument is given, it is the list of directories
  where \bras{} searches for dependencies (see
  section~\ref{secSearchPath}). 

  Note that the searchpath is local to a given directory, i.e. if
  \bras{} follows an \Tt{@}-target to another directory, that
  directory has its own search path.
\item[Example]
You may want to make the search path dependent on the platform on
which you are building.
\begin{verbatim}
  searchpath [list ../generic ../$tcl_platform(platform)]
\end{verbatim}
\end{Describe}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
