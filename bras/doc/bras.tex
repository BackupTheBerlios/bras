\documentclass[12pt]{article}
\usepackage{a4}

\title{\textsf{bras}\\
another kind of `make'\\
\small \copyright 1996,1997 Harald Kirsch}
\author{\relax
Harald Kirsch\\
kir@iitb.fhg.de}

\newcommand{\bras}{\texttt{bras}}
\newcommand{\Bras}{\texttt{Bras}}
\newcommand{\make}{\texttt{make}}
\newcommand{\brasfile}{\texttt{brasfile}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			   \begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\maketitle
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{WARNING}
Everthing said in this document about the variable \texttt{trigger}
(called \texttt{newer} before) is probably a bit off.


\section{Why That?}
If you ever used \texttt{make}, you may have noticed that it has a few
odd features. Most annoying to me are
\begin{itemize}
\item the crazy syntax (tabs as a structuring element!),
\item the way variables are expanded (I never found out, when exactly
this happens),
\item the inability to call makefiles in other directories without
breaking the chain of reasoning,
\item the inability to distinguish between targets that merely need to
  exist, those that must be newer than their dependencies, and others
  which must be made for totally different reasons,
\item the lack of file-targets which always must be build,
\item the inability to cleanly handle commands which generate more
than one file,
\item the lack of a distinction between dependencies which may trigger
a rule and mere prerequisites which cannot trigger a rule, but are
nevertheless necessary to execute the rule's command,
\item the lack of control structures and 
\item the lack of decent pattern matching.
\end{itemize}

It is indisputable that \textbf{the} feature of \texttt{make} ---
rule based command execution --- is most helpful in many situations;
in particular were it seems to be applied most often:
conditional compilation of large programs.

My idea was to combine the key features of \texttt{make} with all the
niceties of a command language, while improving on the misfeatures
mentioned above. In addition, \bras{} allows to define new types of
rules, so that a target can be rebuilt not only because it is out of
date, but because of any reason implemented in a new rule.\footnote{My
first idea was to have at least three types of rules, instead of the one
in \make{}, but someone on the net proposed to generalize the idea so
that new types of rules can be easily implemented.}

Since I personally like Tcl, not the least for its well defined
handling of command line substitution (see \texttt{Tcl(n)} and no
flames, please), I ended up with the present solution. A similar
solution might be possible with other command languages.

%The following sections assume that you have a rough idea what \make\
%is all about and what it does. Maybe I copy an introductory
%section from a \make\ manual here the other day, but until then
%\ldots.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction and Definition of Terms}
\label{SecDefTerms}

Unlike in shell-scripts or programming languages like C, Ada or Java,
in \bras{} the order of command execution is not described with
control-structures like if-then-else, loops, etc., but with rules.
The main ingredients of a rule can be described along the following
example.

\begin{verbatim}
  Newer fft.o {fft.c fft.h} {
    cc -o fft.o fft.c
  }
\end{verbatim}

The \textit{target} of the rule, \texttt{fft.o} in the example, is,
what a rule is all about. The ultimate goal of writing a rule is to
describe what has to be done under certain conditions to bring the
target up-to-date (at least in \bras{}, not
in \make{}). The meaning of up-to-date very much depends on the
type of the rule. The example shows a \texttt{Newer}-rule, so
up-to-date means that the target \texttt{fft.o} is a file
which must be newer than the files \texttt{fft.c} and \texttt{fft.h}.
Other rules implement other meanings of up-to-date.

Usually the notion of the target being up-to-date depends on other
targets, which is why they are called \textit{dependencies} in this
context. In the example, \texttt{fft.c} and \texttt{fft.h} are the
dependencies. In general, dependencies are additional parameters
necessary to check whether the target is up-to-date or not.

The next ingredient of a rule is the \textit{command} deemed suitable
to bring the target up-to-date with regard to the rule's particular
meaning of up-to-date. In fact, \bras{} always assumes that the target
is up-to-date as soon as it has executed the command without error. In
the example, the command specifies a call to the C compiler to compile
\texttt{fft.c} into \texttt{fft.o}.

Finally, there is one additional ingredient to a rule which can be
easily confused with the dependencies (as is the case in \make{}) and
which I call \texttt{prerequisites}. While a dependency can render a
target out-of-date, a prerequisite is something which is necessary only
to execute the command, but which is not needed for the out-of-date
test of the target. A typical example is shown in the following rule:

\begin{verbatim}
  Exist /usr/local/blarilu-2.17 /usr/local {
    mkdir $target
  }
\end{verbatim}

In an \texttt{Exist}-rule, the target is only out-of-date, if it does
not exist.\footnote{A \texttt{DirExist}-rule is not yet implemented,
but can be easily added.} The rule shown specifies that the
\texttt{mkdir}-command shall be executed if the target
\texttt{/usr/local/blarilu-2.17} does not exist.
Because \texttt{/usr/local} is not a
parameter of the up-to-date test for the target, it is a merely a
prerequisite, necessary to execute the \texttt{mkdir}-command; it is
not a dependency.

Since the distinction between dependencies and prerequisites is rather
academic most of the time, which I derive from the fact that \make{}
is quite succesful, although it totally ignores it, \bras{} makes no
distinction between the two --- most of the time. However, if it is
really necessary, the distinction can be made explicit. The practical
treatment of this academic distinction is laid out in
section~\ref{SecPreq}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Standard Rules of Bras}

As mentioned in the previous section, \bras{} distinguishes between
several different meanings of \textit{up-to-date}. While historic
\make{} has only one notion of up-to-date, i.e. the target must exist
and must be newer than its dependencies, \bras{} implements four
different meanings of up-to-date, and others can be added easily. The
current distribution contains four types of rules

\begin{itemize}
\item 
The \texttt{Newer}-rule most closely resembles \make's notion of
\textit{up-to-date}.
\item 
The \texttt{Exist}-rule considers a target to be up-to-date,
if a file of that name exists. The file's modification date is irrelevant.
\item 
The \texttt{Always}-rule considers the target to be never
up-to-date, i.e.\ the rule's commands are always executed if
\bras{} is asked to bring this target up-to-date.
\item
The \texttt{Command}-rule in contrast considers its target to be always
up-to-date, i.e. it never gives a reason to update its target. It is
used to associate a command with a target in a neutral way. The
command can then be share by other rules for the same target.
\end{itemize}

Certainly someone can come up with an application which still cannot
be handled by these types of rules. How about a rule which rebuilts
the target only if \textbf{all} dependencies are newer than the
target, one that rebuilts if a dependency-file is longer than the
target-file, one which rebuilts only, if the moon is in a certain
phase, or $\ldots$ you name it?  Section~\ref{secNewRules} describes
how to implement new rules. For the moment however, only the
rule-types listed above are of interest.

The general form of a rule is
\begin{quote}
\textit{Rulename} \textit{targets} \textit{dependencies} \textit{command}
\end{quote}
where \textit{Rulename} is one of \texttt{Newer}, \texttt{Exist},
\texttt{Always}, \texttt{Command} or the name of an additionally
implemented rule. 

The list \textit{targets} contains one or more targets for the rule. A
rule with more than one target behaves very similar to a list of rules
which are identical except for the targets. However pooling the
targets into one rule tells \bras{} that execution of the rule's
command will generate all the targets immediately, so that the command
is executed only once, even if during the course of reasoning two or
more targets of the rule are found to be out-of-date.

The meaning of the elements of the list \textit{dependencies} very
much depends on the type of rule. It is described in the following
sections. Some rules allow the list to be empty.

Finally, the optional \texttt{command} is a Tcl-script to be executed
if \bras{} reckons that one or more of the rule's targets need to be
updated. It is possible for a target to show up in the target list of
several rules, but at most one of them may have a non-empty
command. Put another way, \bras{} strictly assumes that there can only
be one way to bring a target up-to-date, even if there are several
different and independent reasons why this has to be done. If no
command is given, it is defined to be emtpy.

A command is \textit{empty}, if it is exactly the empty string,
i.e. \verb+{}+ or \verb+""+. Using a string of some blanks on the
other hand is a way to specify a command which does nothing and may
not be replaced by a default command.\footnote{Given that I flame
\make{} for using tabs as a syntactical element, this is probably not
the final solution. I am about to introduce an explicit do-nothing
command called
\texttt{relax} to be used instead of the string of blanks. (No, I do
not steal the name from \TeX, I only borrow it \texttt{:-)}}

The following sections describe the four types of rules in detail.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Newer}-rule}
\label{secNewer}
The rule most familiar to \make-users is probably the
\texttt{Newer}-rule. It has the form:
\begin{quote}
  \texttt{Newer} \textit{targets} \textit{dependencies} \textit{command}
\end{quote}
An example is
\begin{verbatim}
  Newer yummy.o {yummy.c yummy.h} {
    cc $CFLAGS -o $target $deps
  }
\end{verbatim}
For the meaning of \texttt{\$target} and \texttt{\$deps} see
section~\ref{secCmdExec}. If the rule is invoked for one of its
targets, the \textit{command} is executed whenever at least one of the
following conditions holds:
\begin{itemize}
\item No file of name \textit{target} exists in the current directory.
\item A file with name \textit{target} exists but is older than an
existing file contained in the dependency list.
\item Considering each dependency in turn results in the decision to
rebuild one or more of them.
\end{itemize}

If the target does not exist, the \texttt{Newer}-rule can immediately
decide that the target must be rebuild --- without even looking at the
dependencies. However, the rule considers all dependencies to also be
prerequisites (cf.\ section~\ref{SecDefTerms}) and therefore always
considers all of them, regardless of when the decision to remake the
target is made.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Exist}-rule}

One thing that often annoys me using \make{} is the impossibility to
write a decent rule to manage the existence of a directory. Therefore
I introduced the \texttt{Exist}-rule:
\begin{quote}
  \texttt{Exist} \textit{targets} \textit{dependencies} \textit{command}
\end{quote}
An example is
\begin{verbatim}
  Exist /usr/local/bras-0.1 {} {
    mkdir -p $target
  }
\end{verbatim}
If the rule is invoked for one of its targets, the \textit{command} is
executed only if there is no file (or directory) with that name. If
\textit{dependencies} are given, they can never trigger the
rule, i.e. they are rather prerequisites, and all of them are brought
up-to-date, \textbf{before} the \textit{command} is executed.

As and example, the following rules make sure that
\texttt{/usr/local} is not accidently created by \texttt{mkdir -p} if
it does not yet exist.

\begin{verbatim}
  Exist /usr/local/bras-0.1 {/usr/local} {
    mkdir -p $target
  }
  Exist /usr/local {} {
    puts "Sorry, /usr/local must exist before I can proceed."
    exit 1
  }	
\end{verbatim}
The first rule has prerequisite \texttt{/usr/local}. If the target
\texttt{/usr/local/bras-0.1}
does not exist, \texttt{/usr/local} is considered
before execution of \texttt{mkdir}. The second rule checks whether it
exists. If this is the case, it does nothing and the first rule
proceeds with the \texttt{mkdir}-command. But if
\texttt{/usr/local} does not exist, the message is printed and \bras{}
is terminated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Always}-rule}

The \texttt{Always}-rule has the form:

\begin{quote}
  \texttt{Always} \textit{targets} \textit{dependencies} \textit{command}
\end{quote}

An example is
\begin{verbatim}
  Always clean {@lib/clean @src/clean @doc/clean} {
    puts "Everbody's clean now"
  }
\end{verbatim}

If the rule is invoked for one of its targets, the \textit{command} is
always executed. As with the \texttt{Exist}-rule, the
\texttt{dependencies} are rather prerequisites, i.e. \textbf{before}
\textit{command} is executed, all
of them are brought up-to-date.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Command}-rule}
\label{SecCommandRule}
The \texttt{Command}-rule has the form:

\begin{quote}
  \texttt{Command} \textit{targets} \textit{dependencies} \textit{command}
\end{quote}

Whenever the rule is invoked for one of its targets, the
\texttt{command} is \textbf{not} executed. Yes, really! The
purpose of a \texttt{Command}-rule is to bind a command to a target
and specify in the dependency-list the prerequisites needed to
executed the command. In fact, if there are no other rules for the
targets, the rule is useless.

An example use of the \texttt{Command}-rule is as follows: Suppose
a target-file \texttt{userguide.doc} is created be a program
\texttt{blurb} which insists on finding a temporary directory
\texttt{~{}/temp} to work with. Without
\texttt{Command}-rules you would write something like.
\begin{verbatim}
  Newer userguide.doc {userguide.in $(HOME)/temp} {
    blurb userguide.in >userguide.doc
  }
  Exist $(HOME)/temp {} {
    mkdir $target
  }
\end{verbatim}

However, every change in directory \texttt{~{}/temp} results in it
being newer than \texttt{userguide.doc} and triggers the
\texttt{Newer}-rule the next time \bras{} is run. Leaving
\texttt{~{}/temp} out of the dependency list on the other hand is no
good either, because the directory might then be missing, the next
time \texttt{blurb} is run.

The solution with the \texttt{Command}-rule looks like this:
\begin{verbatim}
  Command userguide.doc {$(HOME)/temp} {
    blurb >userguide.doc
  }

  Newer userguide.doc {userguide.in}

  Exist $(HOME)/temp {} {
    mkdir $target
  }
\end{verbatim}

The use of \texttt{Newer} as well as \texttt{Command} effectivly
separates the dependendy \texttt{userguide.in} from the prerequisite
\texttt{~{}/temp}. If \texttt{userguide.in} is newer than
\texttt{userguide.doc}, the \texttt{blurb}-command is executed after
making sure that \texttt{~{}/temp} is up-to-date.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Multiple rules for a target}
In the discussion of section~\ref{SecCommandRule} it was already
mentioned, that there can be several rule of different types for a
target. However, at most one of them may have a nonempty command. Put
another way, \bras{} assumes that there is at most one way to bring a
target up-to-date, but that there may be several independent reasons
why this is necessary. This section describes the lines of \bras'
reasoning for a target with more than one rule.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Reasoning Process}
All that said, \bras's reasoning can be described easily.  After
reading in the brasfile, the target of the very first rule or the
targets given on the command line is considered. For each target it
is decided whether it is up-to-date or not, which is trivial for
\texttt{Always}-rules and easy for \texttt{Exist}-rules, but a bit
elaborate for \texttt{Newer}-rules. If the target is not up-to-date,
\bras\ considers all dependencies in turn and brings them
up-to-date. Then the rule's command is executed and whenever it
finishes without error, \bras\ assumes that the target is
up-to-date. In particular, \bras\ does not check whether a file with
the target's name was produced or not.


















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pattern Rules}

Pattern rules extend on the idea of \make's suffix (or implicit)
rules and serve two purposes:

\begin{enumerate}
\item If there is no rule for a target under consideration, \bras\
tries to find a matching pattern rule and creates a real rule from it on
the fly. The matching process is described in
section~\ref{secSuffixToReal}.
\item If a rule with an empty command is triggered, \bras\ tries
to find a matching pattern rule to substitute its command as a default.
\end{enumerate}

Every rule type has its corresponding pattern rule type. They
are called
\texttt{PatternNewer}, \texttt{PatternExist} and
\texttt{PatternAlways}.

The general form of pattern rules is
\begin{quote}
\texttt{Pattern}\textit{Type regexp depprocs command}
\end{quote}

where 

\begin{description}
\item[\textit{Type}] is either \texttt{Newer}, \texttt{Exist} or
\texttt{Always},
\item[\textit{regexp}] is a regular expression selecting the targets
for which this rule will be used,
\item[\textit{depproc}] is a list of Tcl-procedures that generate
dependencies from a given target and
\item[\textit{command}] is the command to be used in a derived real
rule or as a default command.
\end{description}

The details about \textit{regexp} and \textit{depprocs} are described
in sections~\ref{secSuffixToReal} and~\ref{secSuffixAsDefCmd}.

An example pattern rule to make an object file from a C source file is:
\begin{verbatim}
  SuffixNewer .*\.o .c {
    $CC -c $CFLAGS [file rootname $target].c
  }
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{How pattern rules are used to create real rules}
\label{secSuffixToReal}

As mentioned above, pattern rules are used to create a new rule, if
there is no explicit rule available for the target under
consideration. 
For a given target, the pattern rule to use is selected as described
below.

In the order they were specified, all known pattern rules are checked
as to whether their regular expression matches the target. To make
sure that the whole word matches, regular expressions of pattern rules
get an implicit \verb+^+ and \texttt{\$} prefixed and suffixed. Put
another way: If \texttt{target} is the variable containing the target
under consideration and \texttt{rexp} is the regular expression of a
pattern rule, \bras\ executes an equivalent of
\begin{verbatim}
    regexp "^$rexp\$" $target
\end{verbatim}
to check whether the pattern rule is a \textit{candidate} or not.

Suppose a candidate pattern rule is found for a target named
\texttt{bla.o}. Then two more steps are necessary
to test whether the candidate can really be used.
The first step derives possible dependencies
from \texttt{bla} by calling
an equivalent of
\begin{quote}
    \texttt{Dep}$d$ \texttt{\$target}
\end{quote}
for every element $d$ of the \textit{depprocs}-list of the candidate
pattern rule. For example if \textit{depprocs} contains \texttt{.c}
and \texttt{.s}, \bras\ calls
\begin{verbatim}
    Dep.c $target
    Dep.s $target
\end{verbatim}
to derive possible dependency names. If the procedure \texttt{Dep$d$}
was not defined in a brasfile, the following
default is used:
\begin{quote}
    \verb|proc Dep|$d$\verb|{target} {|\\
    \texttt{\hspace*{2em}return [file root \$target]$d$}\\
    \verb|}|
\end{quote}
It simply strips the file extension from the target and suffixes the
result with $d$. More elaborate
procedures can be defined as needed.

The second step checks if one of
the derived dependencies denotes an existing file.
If the answer is yes, \bras\ creates a real rule with
\begin{itemize}
\item the target under consideration as the rule target,
\item the file found as the only dependency and
\item the command of the pattern rule as the rule's command,
\end{itemize}
and then proceeds as if there had never been a search for a pattern
rule.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{How default commands are derived from pattern rules}
\label{secSuffixAsDefCmd}
Besides being rule patterns, pattern rules are also used to define
default commands, i.e. commands which are used in case a real rule was
defined with an empty command.

I would like to point out that the two uses of pattern rules are
totally unrelated, and that one could as well have introduced the
concept of default commands explicitly. While creation of a new rule
from a pattern rule happens while \bras\ is reasoning about which rules
must be triggered in which order, the extraction of default commands
happens later when the rules are actually triggered. 

Whenever \bras\ triggers a rule with an empty command, it tries to
find a pattern rule in much the same way as described in
section~\ref{secSuffixToReal}, except that in the last step it does
not try to find a file, but instead tests if one of the derived
dependencies is equal to one of the dependencies of the given real
rule. If the test succeeds, the command of the pattern rule is used as
the default command for the real rule.

Suppose the real rule with the empty command is
\begin{verbatim}
  Newer hack.o {hack.c hack.s} {}
\end{verbatim}
and that
\begin{verbatim}
  SuffixNewer .*\.o .s {
    cc -o $target $trigger
  }
\end{verbatim}
is the candidate pattern rule. It is obviously good enough
because the default dependency procedure \texttt{Dep.s} returns
\texttt{hack.s} if called with argument \texttt{hack.o}.

To prevent \bras\ from looking for a default command, use a command
which is \textit{almost} empty, i.e. one which contains only blank
space. It is most convenient to write something like
\begin{verbatim}
  Newer hack.o {hack.c} {
  }
\end{verbatim}
to prevent \bras\ from looking for default commands.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing New Types of Rules}
\label{secNewRules}
As mentioned previously, there might be situations where the standard
rule-types are not sufficient to describe the reasoning necessary to
decide whether a target needs to be made or not. In these special
cases, a new rule-type must be implemented, which is particularly easy
with \bras{}. \Bras{} has a procedure called \texttt{Defrule} which is
used similar to Tcl's \texttt{proc} to define the reasoning to be
used by the rule to be defined.

\begin{quote}\bf
More to come later. For the moment have a look at the implementations
of the Exist- and Newer-Rules in files existRule.tcl and newerRule.tcl
\end{quote}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dependencies in Foreign Directories}

Most annoying to me using \make\ is its unwieldy handling of
dependencies in other directories. The usual solution is to call
\make\ recursively after changing to the foreign directory. But this
breaks the chain of reasoning, because there is no communication
between parent- and child-make as to whether any target was build or
whether all targets were up-to-date.

This is different with \bras. Whenever a dependency starts with
\texttt{@} and points to another directory, \bras\ expects
a \texttt{brasfile} in that directory which describes how the
dependency --- if considered as a target --- has to be constructed.
The following excerpt from a \texttt{brasfile} is an example:

\begin{verbatim}
  Always clean {@lib/clean @src/clean @doc/clean} {
    puts "Cleaning done."
  }
\end{verbatim}

The rule might typically be contained in a top-level
\texttt{brasfile}. Whenever 
\begin{verbatim}
    bras clean
\end{verbatim}
is called, the rule is considered, and consequently all
dependencies in turn are considered as a target. For example
\texttt{@lib/clean} tells \bras\ that there is a subdirectory
\texttt{lib} with a \texttt{brasfile} which
describes how to handle the target \texttt{clean}. To learn
the rule, \bras\ reads \texttt{lib/brasfile} and acts accordingly.
In particular \bras\ changes to directory \texttt{lib}
before executing any command associated with a rule in
\texttt{lib/brasfile}. The other targets are handled similarly.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{How Commands are Executed}
\label{secCmdExec}

All commands derived from rules are executed on the global level
so that they have access only to all global variables. In addition
to the global variables defined in the
\texttt{brasfile}, \bras\ sets the variables \texttt{target},
\texttt{deps} and \texttt{trigger} respectively to the rule's target, its
dependencies and the dependencies that are newer than the target. If
the target does not exist, all dependencies are considered newer and
\texttt{deps} and \texttt{trigger} will contain the same value(s).

Non-internal commands are automatically executed
via \texttt{exec}. But please remember that \bras\ is basically
Tcl and unlike \texttt{sh}, \texttt{tclsh} and therefore \bras\ does no
globbing on the command line. Consequently, the rule
\begin{verbatim}
    Always clean {
      rm *.o *.a *~
    }
\end{verbatim}
does not work as expected. You have to resort to
\begin{verbatim}
   Exist clean {
      rm [glob -nocomplain -- *.o *.a *~]
    }
\end{verbatim}
    
A delicate problem is variable substitution in
external commands. Suppose \texttt{CFLAGS} is set to 
\texttt{"-g -Wall"} and there is a command like 

\begin{verbatim}
    cc $CFLAGS -c $target
\end{verbatim}

If external commands were only exec'ed you couldn't expect this to
work, because it were equivalent to the tcl-script

\begin{verbatim}
    exec cc $CFLAGS -c $deps
\end{verbatim}

which calls \texttt{cc} with just 3 arguments resulting effectively in

\begin{verbatim}
    cc "-g -Wall" -c whatever.c
\end{verbatim}

To make it work, \bras\ actually does

\begin{verbatim}
    eval exec cc $CFLAGS -c $target
\end{verbatim}

but beware of unwanted flattening in commands containing braces: Due
to \texttt{eval} one level of braces
disappears so that

\begin{verbatim}
    sed -e {s/^[/]*//} bla >bli
\end{verbatim}

after \texttt{eval} is actually called as

\begin{verbatim}
    exec -e s/^[/]*// bla >bli
\end{verbatim}

resulting in tcl complaining about the unknown command in
\texttt{[/]}. The remedy is an extra level of braces. While this might
seem clumsy, I find it still much more elegant than the backslashing
necessary in makefiles.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Use of automatically generated Dependencies}

Most C-compilers are able to generate makefile-dependencies for
source files by determining which files are included with
\texttt{\#include} directives. For example \texttt{gcc} can be
instructed to do so with option \texttt{-M} while SUN's Solaris
C-compiler uses \texttt{-xM}. Because this is a valuable feature,
\bras\ has the ability to read and understand a restricted type of
\make-dependencies. The command
\begin{quote}
  \texttt{sourceDeps} \textit{file}
\end{quote}
reads a dependency file created by the C-compiler and creates the
appropriate \texttt{Newer}-rules. The command prints a warning, if
the given file does not exist.
   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Limitations and Known Bugs}


\begin{enumerate}
\item
Since I did not yet test \bras\ with a really big project like say
\texttt{Xemacs} or \texttt{Tcl/Tk}, I don't know if the recursive
inclusion of many \texttt{brasfile}s will lead to performance
problems.

\item
When sourcing \texttt{brasfile}s from other directories, \bras\
currently does not construct a local scope for the variables used
there. The effect is that it is not possible to use the same variable
name, e.g.\ \texttt{SRC} and \texttt{OBJ}, in the brasfiles
of all subdirectories. This may be corrected in the future by using a
separate interpreter in every directory.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Name of the Game}

First I wanted to call it \texttt{brassel} which is the imperative of
\texttt{brasseln}, a verb you probably won't find in the
dictionary. You may need to ask someone from around K\"oln, but be
prepared to get the answer that (s)he knows what it means but cannot
explain it. I think the description "`working concentrated, busily but
without stress"' is quite close to the real meaning.

Well, since \texttt{brassel} is much to long for a good
Un*x utility, I shortened it to \bras.
    
\end{document}
