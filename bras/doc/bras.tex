\documentclass[12pt]{article}
%\usepackage{bookman}
\usepackage{a4}

%%%%%%%%%%%%%%%%%%%%%%%%
%
% $Revision: 1.17 $, $Date: 1999/02/21 21:46:42 $
%
%%%%%%%%%%%%%%%%%%%%%%%%


\title{\textsf{bras}\\
another kind of `make'\\
\small \copyright 1996,1997 Harald Kirsch}
\author{\relax
Harald Kirsch\\
kir@iitb.fhg.de}

\newcommand{\bras}{\texttt{bras}}
\newcommand{\Bras}{\texttt{Bras}}
\newcommand{\make}{\texttt{make}}
\newcommand{\brasfile}{\texttt{brasfile}}

\parindent 0pt
\parskip 1ex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                           \begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\maketitle
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Why That?}
If you ever used \texttt{make}, you may have noticed that it has a few
odd features. Most annoying to me are

\begin{itemize}
\item 
the crazy syntax (tabs as a structuring element!),
\item 
the way variables are expanded (I never found out, when exactly
this happens),
\item 
the inability to call makefiles in other directories without
breaking the chain of reasoning\footnote{In the meantime I learned
  that this is not totally true for all versions of \make.},
\item 
the inability to distinguish between targets that merely need to
  exist, those that must be newer than their dependencies, and others
  which must be made for totally different reasons,
\item 
the lack of file-targets which always must be build,
\item 
the inability to cleanly handle commands which generate more
than one file,
\item 
the lack of a distinction between dependencies which may trigger
a rule and mere prerequisites which cannot trigger a rule, but are
nevertheless necessary to execute the rule's command,
\item 
the lack of control structures,
\item 
the lack of decent pattern matching, and
\item 
the inability to fine-tune dependency lists and commands associated
with a target incrementally within the rule file.
\end{itemize}

It is indisputable that \textbf{the} feature of \texttt{make} ---
rule based command execution --- is most helpful in many situations;
in particular were it seems to be applied most often:
conditional compilation of large programs.

My idea was to combine the key features of \texttt{make} with all the
niceties of a command language, while improving on the misfeatures
mentioned above. \Bras{} allows to define new types of
rules, so that a target can be rebuilt not only because it is out of
date, but because of any reason implemented in a new rule.\footnote{My
first idea was to have at least three types of rules, instead of the one
in \make{}, but someone on the net proposed to generalize the idea so
that new types of rules can be easily implemented.}

Since I personally like Tcl, not the least for its well defined
handling of command line substitution (see \texttt{Tcl(n)} and no
flames, please), I ended up with the present solution. A similar
solution might be possible with other command languages.

%The following sections assume that you have a rough idea what \make\
%is all about and what it does. Maybe I copy an introductory
%section from a \make\ manual here the other day, but until then
%\ldots.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction and Definition of Terms}
\label{SecDefTerms}

Unlike in shell-scripts or programming languages like C, Ada or Java,
in \bras{} the order of command execution is not only described with
control-structures like if-then-else, loops, etc., but with rules.
The main ingredients of a rule can be described along the following
example.

\begin{verbatim}
  Newer fft.o {fft.c fft.h} {
    cc -o fft.o fft.c
  }
\end{verbatim}

The file \texttt{fft.o} is called the \textit{target} of the rule. The
ultimate goal of writing a rule is to describe what has to be done
under certain conditions to bring the target up-to-date. The meaning
of up-to-date depends on the type of the rule (at least in
\bras{}). The example shows a \texttt{Newer}-rule, so
up-to-date means that the target \texttt{fft.o} is a file which must
be newer than the files \texttt{fft.c} and \texttt{fft.h}. Other
types of rules implement other meanings of up-to-date.

Usually the notion of the target being up-to-date depends on other
targets, which is why they are called \textit{dependencies} in this
context.\footnote{From Webster's entry \textit{dependency} I conclude
  that this is a misnomer. But it is well known in the context of
  \make{}, so I stick to it.} In the example, \texttt{fft.c} and
\texttt{fft.h} are the dependencies.  Dependencies can be understood
as parameters necessary to check whether the target is up-to-date or
not.

The next ingredient of a rule is the \textit{command} deemed suitable
to bring the target up-to-date with regard to the rule's particular
meaning of up-to-date. \Bras{} assumes that the target
is up-to-date as soon as it has executed the command without error. In
the example, the command specifies a call to the C compiler to compile
\texttt{fft.c} into \texttt{fft.o}.

There is one additional ingredient to a rule which can be easily
confused with the dependencies. While a dependency can render a target
out-of-date, there might be files necessary to execute the rule's
command, but which don't influence the target's being up-to-date.
They are called \texttt{prerequisites}. As an example consider the
following rule:

\begin{verbatim}
  Exist /usr/local/blarilu-2.17 {/usr/local} {
    mkdir $target
  }
\end{verbatim}

In an \texttt{Exist}-rule, the target is only out-of-date if it does
not exist. The rule shown specifies that the \texttt{mkdir}-command
must be executed whenever the target \texttt{/usr/local/blarilu-2.17} does
not exist.  Because \texttt{/usr/local} is not a parameter of the
up-to-date test for the target, it is a merely a prerequisite and not
a dependency.

The distinction between dependencies and prerequisites is rather
academic most of the time, which I derive from the fact that \make{}
is quite successful, although it totally ignores this distinction.
\Bras{} on the other hand allows to explicitely specify prerequisites.
Because an \texttt{Exist}-rule by definition has no dependencies,
\texttt{/usr/local} is understood as a
prerequisite. \texttt{Newer}-rules may have both, dependencies and
prerequisites. They are separated by a double-slash (\texttt{//}), e.g.:

\begin{verbatim}
  Newer specialDigest {this that and other files // makeDigest} {
    makeDigest $deps
  }
\end{verbatim}

The double-slash, if present, marks the end of the dependency list.
All names behind it are understood as mere prerequisites.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Standard Rules}
\label{SecStandardRules}
As mentioned in the previous section, \bras{} distinguishes between
different meanings of \textit{up-to-date}. While historic
\make{} has only one notion of up-to-date, i.e. the target must exist
and must be newer than its dependencies, \bras{} currently implements
four different meanings of up-to-date. Others can be added
easily.

\begin{itemize}
\item 
The \texttt{Newer}-rule most closely resembles \make's notion of
\textit{up-to-date}.
\item 
The \texttt{Exist}-rule considers a target to be up-to-date,
if a file of that name exists. The file's modification time is irrelevant.
\item 
The \texttt{Always}-rule considers the target to be never
up-to-date, i.e.\ the rule's commands are always executed if
\bras{} is asked to bring this target up-to-date.
\item
The \texttt{DependsFile}-rule is a cute beast invented to ease the
handling of the dependency between a C source file and the included
header files. See section~\ref{sec:DependsFile} for details. 
\end{itemize}

Certainly someone can come up with an application requiring other
types of rules. How about a rule which rebuilts
the target only if \textbf{all} dependencies are newer than the
target, one that rebuilts if a dependency-file is longer than the
target-file, one which rebuilts only, if the moon is in a certain
phase, or $\ldots$ you name it?  Section~\ref{secNewRules} describes
how to implement new rules. For the moment however, only the
rule-types listed above are of interest.

The general form of a rule is
\begin{quote}
\textit{Rulename} \textit{targets} \textit{depreq} \textit{command}
\end{quote}
where \textit{Rulename} is one of \texttt{Newer}, \texttt{Exist},
\texttt{Always}, \textit{DependsFile} or the name of an additionally
implemented rule. 

\paragraph{Targets:}
The list \textit{targets} contains one or more targets for the rule. A
rule with more than one target behaves very similar to a list of rules
which are identical except for the targets. However pooling the
targets into one rule tells \bras{} that execution of the rule's
command will update all the targets. Consequently the command
is executed only once, even if during the course of reasoning two or
more targets of the rule are found to be out-of-date.

\paragraph{Dependencies and Prerequisites:}
The list \textit{depreq} contains dependencies as well as
prerequisites. Both are separated by a double-slash (\texttt{//}). If
there is no double-slash, the interpretation depends on the rule-type.
Because \texttt{Exist}- and \texttt{Always}-rules don't need
dependencies, all elements of \textit{depreq} are interpreted as
prerequisites. For other rule-types the list elements are understood as
dependencies in the absence of a double-slash.

Please note that the double-slash must be a Tcl-word on its own as
shown in this example \textit{depreq}-list.
\begin{verbatim}
  {a.c a.h ../lib/x.h // /usr/local/bla /what/now}
\end{verbatim}
It must be separated from neighbour words by white-space to make sure
it cannot be confused with a double-slash which crept into a pathname.

While the meaning of dependencies, i.e. the words in front of the
double-slash, depends on the rule-type, prerequisites are treated the
same for all rules. They don't influence the reasoning mechanism which
decides if a rule fires or not. Only after the rule-interpreter
decided for a rule to fire, it recursively considers all
preqrequisites in turn as targets to make sure they are available
before the rule's command is run.

\paragraph{Command:}
The optional \texttt{command} is a Tcl-script to be executed if
\bras{} reckons that one or more of the rule's targets need to be
updated. If no command is given, it is defined to be emtpy. Empty
commands are replaced by default commands as explained in
section~\ref{secSuffixAsDefCmd}. 

A command is \textit{empty}, if it is exactly the empty string,
i.e. \verb+{}+ or \verb+""+. Using a string of some blanks on the
other hand is a way to specify a command which does nothing and may
not be replaced by a default command.\footnote{Given that I flame
\make{} for using tabs as a syntactical element, this is probably not
the final solution. I might introduce an explicit do-nothing
command in later versions}.

The following sections describe the available rule-types in detail.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Newer}-rule}
\label{secNewer}
The rule most familiar to \make-users is the
\texttt{Newer}-rule. It has the form:
\begin{quote}
  \texttt{Newer} \textit{targets} \textit{depreq} \textit{command}
\end{quote}
An example is
\begin{verbatim}
  Newer yummy.o {yummy.c yummy.h} {
    cc $CFLAGS -o $target $deps
  }
\end{verbatim}
For the meaning of \texttt{\$target} and \texttt{\$deps} see
section~\ref{secCmdExec}. If the rule is invoked for one of its
targets, the \textit{command} is executed whenever at least one of the
following conditions holds:
\begin{itemize}
\item No file of name \textit{target} exists in the current directory.
\item A file with name \textit{target} exists but is older than an
existing file contained in the dependency list \textbf{after} the
files of the dependency-list have been considered and possibly
updated.
\end{itemize}

If the target does not exist, the \texttt{Newer}-rule can immediately
decide that it must be rebuild --- without even looking at the
dependencies. But if it does not look at the dependencies, they might
not be correctly built before the rule's command is
executed. Therefore even if the target does not exist, all
dependencies are considered in turn.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Exist}-rule}

One thing that often annoys me using \make{} is the impossibility to
write a decent rule to manage the existence of a directory. Therefore
I introduced the \texttt{Exist}-rule:
\begin{quote}
  \texttt{Exist} \textit{targets} \{// \textit{prerequisites}\} \textit{command}
\end{quote}
The double-slash is optional and even without it, all elements of that
list are understood as prerequisites.  An example is
\begin{verbatim}
  Exist /usr/local/bras-0.1 {} {
    mkdir -p $target
  }
\end{verbatim}
If the rule is invoked, the \textit{command} is executed only if
there is no file (or directory) with that name.  It is an error to
specify dependencies for an \texttt{Exist}-rule.

As an example, the following rules make sure that \texttt{/usr/local}
is not accidently created by \texttt{mkdir -p} if it does not yet
exist.

\begin{verbatim}
  Exist /usr/local/bras-0.1 /usr/local {
    mkdir -p $target
  }
  Exist /usr/local {} {
    puts "Sorry, /usr/local must exist before I can proceed."
    exit 1
  }     
\end{verbatim}

The first rule has prerequisite \texttt{/usr/local}. If the target
\texttt{/usr/local/bras-0.1}
does not exist, \texttt{/usr/local} is considered
before execution of \texttt{mkdir}. The second rule checks whether it
exists. If this is the case, it does nothing and the first rule
proceeds with the \texttt{mkdir}-command. But if
\texttt{/usr/local} does not exist, the message is printed and \bras{}
is terminated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{Always}-rule}

The \texttt{Always}-rule has the form:

\begin{quote}
  \texttt{Always} \textit{targets} \{// \textit{prerequisites}\} \textit{command}
\end{quote}

An example is
\begin{verbatim}
  Always clean {@lib/clean @src/clean @doc/clean} {
    puts "Oh, what a dirty job."
  }
\end{verbatim}

If the rule is invoked for one of its targets, the \textit{command} is
always executed. As with the \texttt{Exist}-rule prerequisites may be
specified but no dependencies.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{DependsFile}-rule}
\label{sec:DependsFile}

The \texttt{DependsFile}-rule was invented to handle the dependency
between C source files and the included header files. To understand
why this is difficult, please note the following: An object file
depends on its source file and on all the header-files it
(recursively) includes. Fixing this list at some point in time in the
depencency list of a \texttt{Newer}-rule will lose as soon as an
additional file is included into the source.

A correct approach would be to have a dynamic dependency list which is
generated anew whenever the source file is considered. But generation
of the list requires to read the source file and all (recursively)
included header files --- exactly what all this rule-business tries to
avoid.

A better approach is to cache the dependency list in a special
file. Whenever the source file or one of the files listed in the
cache file is changed, the cache needs to be regenerated and the
source must be compiled.

The \texttt{DependsFile}-rule is used to manage the cache-file. Its
general form is the same as for the other rules:
\begin{quote}
  \texttt{DependsFile} \textit{targets} \texttt{dependencies}
 \textit{command}
\end{quote}

It expects a target to be a file which contains file names. If the
target does not exist, it is supposed to be out of date and triggers
execution of the command. Otherwise, the target is read and whatever
is found is appendend to the dependency list. The resulting pair 
(target, dependency list) is than handled as if it were found in a
\texttt{Newer}-rule. In fact, internally it is handed to the
evaluator of \texttt{Newer}-rules.

An example use is demonstrated below:

\begin{verbatim}
  Newer a.o a.dep {
    compile a.c into a.o
  }
  DependsFile a.dep a.c {
    extract names of included files from a.c 
    and store the list in a.dep
  }
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pattern Rules}

Pattern rules extend on the idea of \make's suffix (or implicit)
rules and serve two purposes:

\begin{enumerate}
\item 
If there is no rule for a target under consideration, \bras{}
tries to find a matching pattern rule and creates a real rule from it on
the fly. The matching process is described in
section~\ref{secSuffixToReal}.
\item 
If a rule with an empty command is triggered, \bras{} tries
to find a matching pattern rule to substitute its command as a default.
\end{enumerate}

Every rule type has its corresponding pattern rule type. 
For a rule with name \textit{Type} the pattern rule has the name
\texttt{Pattern}\textit{Type}. For the build-in rules the names are
\texttt{PatternNewer}, \texttt{PatternExist},
\texttt{PatternAlways} and \texttt{PatternDependsFile}.

The general form of pattern rules is
\begin{quote}
\texttt{Pattern}\textit{Type regexp deptag command}
\end{quote}

where 

\begin{description}
\item[\textit{Type}] 
  is \texttt{Newer}, \texttt{Exist},
  \texttt{Always}, \texttt{DependsFile}, or the name of an additionally
  implemented rule, 
\item[\textit{regexp}] 
  is a regular expression selecting the targets
  for which this rule will be used,
\item[\textit{deptag}]
  is a tag which is used to select functions called to aid the
  process of selecting the correct pattern rule. The meaning of the
  tag is described in the following sections.
\item[\textit{command}] 
  is the command to be used in a derived real
  rule or as a default command.
\end{description}

The details about \textit{regexp} and \textit{deptag} are described
in sections~\ref{secSuffixToReal} and~\ref{secSuffixAsDefCmd}.

An example pattern rule to make an object file from a C source file is:
\begin{verbatim}
  PatternNewer .*\.o .c {
    $CC -c $CFLAGS $trigger
  }
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{How pattern rules are used to create real rules}
\label{secSuffixToReal}

As mentioned above, pattern rules are used to create a new rule if
there is no explicit rule available for the target under
consideration. 
For a given target, the pattern rule to use is selected as described
below.

All known pattern rules are checked in the opposite order in which
they were specified. The rule must pass two tests to be selected.
First, the given real target must match the pattern rule's regular
expression. To make sure that the whole word matches, regular
expressions of pattern rules get an implicit \verb+^+ and \texttt{\$}
prefixed and suffixed. Put another way: If \texttt{target} is the
variable containing the target under consideration and \texttt{rexp}
is the regular expression of a pattern rule, \bras{} executes an
equivalent of
\begin{verbatim}
    regexp "^$rexp\$" $target
\end{verbatim}
to check whether the pattern rule is a \textit{candidate} or not.

Suppose a candidate pattern rule is found for a target named
\texttt{bla.o}. Then a second test is necessary to check whether the
candidate can really be used. The test is a two-step operation.  The
first step derives a dependency from \texttt{bla.o} by calling an
equivalent of
\begin{quote}
    \texttt{GenDep}$deptag$ \texttt{\$target}
\end{quote}
For example if \textit{deptag} is \texttt{.c}, \bras{} calls
\begin{verbatim}
    GenDep.c $target
\end{verbatim}
to derive a dependency name. If the procedure \texttt{Dep$deptag$}
was not defined in a brasfile, the following
default is used:
\begin{quote}
  \verb|proc Dep|$deptag$ \verb|{target} {|\\
    \texttt{\hspace*{2em}return [file root \$target]$deptag$}\\
    \verb|}|
\end{quote}
It strips the file extension from the target and suffixes the
result with $deptag$. More elaborate procedures can be defined if needed.

The second step checks if 
the derived dependency is either an existing file or if a real rule
exists with the dependency is a target.
If the answer is yes, \bras{} creates a real rule with
\begin{itemize}
\item the target under consideration as the rule target,
\item the file found as the only dependency/prerequisite and
\item the command of the pattern rule as the rule's command.
\end{itemize}
It then proceeds as if there had never been a search for a pattern
rule.

If, after checking all pattern rules with the above tests, none is
selected, \bras{} tries one other thing. For each rule where the
target matches the rule's target regular expression, a dependency is
derived as described above. Then this is taken as a new target and
\bras{} calls the above pattern-rule selection recursively. It is made
sure, that the recursion does not loop infinitely by not trying any
pattern-rule on different recursion levels at the same time.

Ultimately, \bras{} will either run out of pattern-rules, in which
case it decides that there is no rule for the target, or it derives a
dependency which either exists as a file or has an explicit rule. All
intermediate pattern-rules are then converted to real rules and the
reasoning proceeds as if there were never any rules missing.

The algorithm is (should be :-) implemented in the file
\texttt{lastMinuteRule.tcl}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{How default commands are derived from pattern rules}
\label{secSuffixAsDefCmd}
Besides being rule patterns, pattern-rules are also used to define
default commands, i.e. commands which are used in case a real rule was
defined with an empty command.

I would like to point out that the two uses of pattern rules are
totally unrelated, and that one could as well have introduced the
concept of default commands explicitly. While creation of a new rule
from a pattern rule happens while \bras{} is reasoning about which rules
must be triggered in which order, the extraction of default commands
happens later when the rules are actually triggered. 

Whenever \bras{} triggers a rule with an empty command, it tries to
find a pattern rule. Only in its first step is this algorithm similar
to the on described in section~\ref{secSuffixToReal}. All
pattern-rules are checked in the opposite order in which they were
entered. If the real target matches the target regular-expression of
the rule, the rule is a candidate.

In contrast to section~\ref{secSuffixToReal} here we have one or more
dependencies available, so none must be derived. Instead of calling
\texttt{GenDep$deptag$}, \bras{} calls \texttt{MatchDep$deptag$} with
the real target as the first parameter and the list of dependencies as
the second parameter. Whenever \texttt{MatchDep$deptag$} returns a
non-empty list, \bras{} uses the command associated to the
pattern-rule under consideration as the default command it was looking
for. 

The default implementation of \texttt{MatchDep$deptag$}, e.g.\ with
\texttt{.c} as the $deptag$, only tries to match every dependency with
the glob-pattern \texttt{*$deptag$} (e.g.\ \texttt{*.c}) and returns
the list of matching dependencies. In particular the default
implementation does not look at its target parameter. The idea is,
that more elaborate versions of \texttt{MatchDep$deptag$}-functions
may need also the target to decide whether the pattern-rule's command
is suitable to built it.

The list returned by a \texttt{MatchDep$deptag$}-function is made
available to the command via the global variable
\texttt{patternTriggers} (cf.\ section~\ref{secCmdExec}).

To prevent \bras\ from looking for a default command, use a command
which is \textit{almost} empty, i.e.\ one which contains only blank
space. It is most convenient to write something like
\begin{verbatim}
  Newer hack.o {hack.c} {
  }
\end{verbatim}
to prevent \bras{} from looking for default commands.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fine tuning the Rule Base}
\begin{quote}\itshape
This section is not complete. It is not even written. The following
notes are only hints about what is possible. The described functions
are not very well tested and their interface might change in the
future.
\end{quote}

\begin{itemize}
\item
Every target has associated three lists: dependency list, prerequisite
list and command list.
\item
If more than one rule is given for a target, the lists are
concatenated. 
\item
The commands \texttt{ClearCmd}, \texttt{ClearDeps},
\texttt{ClearPreqs}, can be used to explicitely clear the respective
lists for a given target.
\item
The commands \texttt{GetCmd}, \texttt{GetDeps}, and
\texttt{GetPreqs} return the lists. Thus normal Tcl-commands can be
used to fiddle e.g.\ with the dependency list incrementally. This may
mainly be useful for automatic generation of rules.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dependencies in Other Directories}

Most annoying to me using \make{} is its unwieldy handling of
dependencies in other directories. Calling \make{} recursively after
changing to the foreign directory often breaks the chain of reasoning,
because there is no communication between parent- and child-make as to
whether any target was build or whether all targets were up-to-date.

\Bras{} allows a different solution. Whenever a dependency starts with
\texttt{@} and does not belong to the current directory, \bras{} expects
a \texttt{brasfile} in the directory where the dependency belongs
to. It uses the rules found there to reason about the dependency ---
if considered as a target.  The following excerpt from a
toplevel \texttt{brasfile} is an example:

\begin{verbatim}
  Always clean {@lib/clean @src/clean @doc/clean} {
    puts "Cleaning done."
  }
\end{verbatim}

Whenever the command \texttt{bras clean}
is called, the rule is considered, and consequently all
prerequisites in turn are considered as a target. For example
\texttt{@lib/clean} tells \bras{} that there is a subdirectory
\texttt{lib} with a \texttt{brasfile} which
describes how to handle the target \texttt{clean}. To learn
the rule, \bras{} reads \texttt{lib/bras\-file} and acts accordingly.
In particular \bras{} changes to directory \texttt{lib}
before executing any command associated with a rule in
\texttt{lib/brasfile}. The other targets are handled similarly.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Including Files Only Once}

As described in the previous section, \bras{} automatically sources
the rule file in other directories if an \texttt{@}-dependency leads
there. But this mechanism is not very useful to source a file with
overall definitions. For this, the Tcl-builtin command
\texttt{source} could be used, but it has the disadvantage that it
does not guard against sourcing the same file twice.

To make sure a file is sourced exactly once, use the
\texttt{include}-command. It takes as its only parameter the file to
read. 

Thats the simple truth, but consider the following setup. The main
directory of application \texttt{bla} has a \texttt{brasfile} and also
several subdirectories like \texttt{lib}, \texttt{extrabla},
\texttt{nobla}, etc. the targets of which are called from the main
\texttt{brasfile} by means of \texttt{@}. Now, what happens,
if you intend to solely work in directory \texttt{lib} for some time?
What is the best way within \texttt{bla/lib/brasfile} to get access to all
those general definitions in \texttt{bla/brasfile}?

Using \texttt{include ../brasfile} will not work, because all
rules of \texttt{bla/brasfile} would be interpreted relative to
\texttt{bla/lib}, which is usually wrong. The correct solution would
be:
\begin{verbatim}
  cd ..
  include brasfile
  cd bla
\end{verbatim}
Since this is tedious to type, you may use
\begin{verbatim}
  include @..
\end{verbatim}
which does the right thing.

Hint: If the included script needs to know its own name, use the
standard Tcl-command \texttt{info script}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Searching for Dependencies}

In built-environments were the source directories are read-only,
compiled files must be put into a different directory than source
files. If in addition builts for different platforms must be supported,
source files may be found in different directories depending on the
platform for which the built is performed.

One way to support that would be to create explicit rules in a loop
for all source files listed e.g. in variable \texttt{SRC}:
\begin{verbatim}
  foreach x $SRC {
    set base [file root $x]
    lappend OBJ build/$base.o
    Newer build/$base.o $platform/$base.c
  }
  Newer all $OBJ {}
\end{verbatim}

However this has at least two drawbacks:
\begin{enumerate}
\item The few lines above will become even more elaborate as soon as a
  source file may be either platform-specific or generic.
\item Pattern rules are no longer used because all rules are
  explicitely constructed.
\end{enumerate}

To overcome these drawback, the command \texttt{searchpath} was
introduced. With one argument it registers a list of pathnames which are
used to locate dependencies, e.g.
\begin{verbatim}
  searchpath {. ./generic ./unix}
\end{verbatim}
Whenever \bras{} looks at a dependency which qualifies as
\begin{verbatim}
  [file pathtype ...]==relative
\end{verbatim}
it tries to find it along the search path. The file found is then
taken as the true dependency. If no file of that name can be found
along the path, it is assumed that the file was found in the first
directory listed. Therefore the current directory, i.e. a single dot,
should almost always be the first element in the list given to
\texttt{searchpath}.

For implicit dependencies, i.e. those which come into being by
application of a pattern rule, the search is not only successful, if
the dependency can be found as a file, but also if it can be found as
the target of an explicit rule.

The search path declared with \texttt{searchpath} is always local for
the current directory, i.e. if \bras{} follows an \texttt{@}-target to
a different directory, this directory has its own search path.

To query the current search path, use \texttt{searchpath} without
arguments. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Use of automatically generated Dependencies}

Most C-compilers are able to generate makefile-dependencies for
source files by determining which files are included with
\texttt{\#include} directives. For example \texttt{gcc} can be
instructed to do so with option \texttt{-M} while SUN's Solaris
C-compiler uses \texttt{-xM}. Because this is a valuable feature,
\bras\ has the ability to read and understand a restricted type of
\make-dependencies. The command
\begin{quote}
  \texttt{sourceDeps} \textit{file}
\end{quote}
reads a dependency file created by the C-compiler and creates the
appropriate \texttt{Newer}-rules. The command prints a warning if
the given file does not exist.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using environment variables}
One of the nicer features of \make\ is its ability to override
variable values in the makefile with values from the command line or
from the environment with \texttt{var=value} or \texttt{-e}
on the command line respectively. 

A similar feature exists in \bras. To set a variable in a way that it
can be overridden by the environment or on the command line, use
\texttt{getenv} instead of \texttt{set} in your brasfiles. Example:
\begin{verbatim}
  getenv prefix /usr/local
\end{verbatim}
This will set \texttt{prefix} to \texttt{\$env(prefix)} or, if this does
not exist, to \texttt{/usr/local}. If you require an environment
variable to be set, leave out the default as in
\begin{verbatim}
  getenv BLA
\end{verbatim}
This will result in a Tcl-error, if there is no variable with name
\texttt{BLA} in the environment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Execution of \Bras}

There are the following major phases of operation performed strictly in
sequence.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Set \texttt{env}-entries from the Command Line}
All definitions like \texttt{var=value} found on the command
line are entered into the global array \texttt{env} thereby
overriding the respective values from the environment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Read Default Rule Files}
If not suppressed with option \texttt{-r}, a default rule file is read
to create default pattern rules and to set reasonable defaults to some
global variables like \texttt{CC}, etc. Of course these defaults do
not override any values found in the environment or on the command line.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Read \texttt{brasfile}}

After that the \texttt{brasfile} is read and executed. Here
\textit{execution} denotes execution in the sense of Tcl. Every rule
is actually a Tcl-\texttt{proc} which \textbf{only records} the rule
in an internal database. In particular, no commands specified in a
rule are executed.

But rules are not always totally passive in the first phase. 
If called with option \texttt{-es} (for \textbf{e}arly
\textbf{s}ourcing), the following happens.
If a dependency or prerequisite starts with \texttt{@}, \bras{}
temporarily changes to the directory of the dependency and sources the
\texttt{brasfile} it finds there. It reports an error, if there is no
\texttt{brasfile} with the same name as the primary
\texttt{brasfile}. Even if several dependencies of different rules lead
to the same directory, the \texttt{brasfile} is sourced only once.

Option \texttt{-es} is mainly available for historic reasons. Without
it, \bras{} reads \texttt{brasfile}s in other directories on demand
during the reasoning process (section~\ref{secReasoning}). Instead of
\texttt{-es} you should consider using the command \texttt{include}
with a parameter starting with \texttt{@}.

Beside rules, any Tcl-command can be used in a \texttt{brasfile}. They
are executed as in every other Tcl-script. Useful examples are setting
of global variables or \texttt{if}-statements including or excluding
system-specific rules.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reasoning Process}
\label{secReasoning}
Either the targets given on the command line or the targets of the
very first rule found in \texttt{brasfile} are considered in
turn. Considering a target can have three different results. 
\begin{enumerate}
\item
The target is up-to-date.
\item
The target is not up-to-date and there is a way to built it.
\item
The target is not up-to-date, but something necessary for building it
is missing and cannot be build.
\end{enumerate}
Checking a target is a recursive process. It requires consideration of
the target's dependencies and of the selected rule's
prerequisites. The exact order and interpretation of recursive calls
of the reasoning process are described below.\footnote{The most
precise description of what \bras{} does is in the
source file \texttt{consider.tcl}. I do my best to match it as close
as possible.}

$\bullet$ The search path is applied to the target if it is a relative
path name.

$\bullet$ If the target was considered already along another line of
reasoning, it is not checked again. Instead the result computed before
is immediately returned.

$\bullet$ If the target starts with the character \texttt{@}, it leads
to another directory and the \texttt{brasfile} of that directory
contains the relevant rules. \Bras{} changes to that
directory and restricts the applicable rules to those found in that
directory's \texttt{brasfile}.

$\bullet$ If no rule is applicable for the target, \bras{} tries to
make one up as desribed in section~\ref{secSuffixToReal}. If none can be
constructed, the reasoning process returns immediately with one of two
results: If the target denotes an existing file, it reports that the
target is up-to-date. Otherwise it reports that the target is not
up-to-date and cannot be built.

If a rule reports that the target is up-to-date,
the reasoning process immediately returns this to its calling parent.

If a rule decides that the target is out-of-date \textbf{and} if
considering all prerequisites of the rule returns that they are all
up-to-date or were built during recursive consideration, then this
rule's command is selected to update the target.

If a rule reports problems either with dependencies or
prerequisites, the reasoning process returns to its parent the result
that the target needs an update, but that it cannot be build.

$\bullet$ The selected command is executed. Details on how this is
done can be found in section~\ref{secCmdExec}.

Versions of \bras{} up to and including 0.6.0 merely recorded the
command on a list. Only after all reasoning was done was this list
executed. Newer versions immediately execute the command.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Command Execution}
\label{secCmdExec}

All commands derived from rules are executed on the global level so
that they have access to all global variables. Before executing a
command, \bras{} additonally sets the following variables:

\begin{description}
\item[\texttt{targets}] 
contains the list of targets for that rule,

\item[\texttt{target}] 
is the name of the target for which the rule
was invoked,

\item[\texttt{deps}] 
is the list of the rule's dependencies,

\item[\texttt{preq}] 
is the list of the rule's prerequisites,

\item[\texttt{trigger}]
contains those elements of \texttt{deps} which rendered the target
out-of-date. The contents of this variable depend on the type of
rule. For a \texttt{Newer}-rule it contains all dependencies which are
newer than the target, and all dependencies, if the target does not
exist. \texttt{Exist}- and \texttt{Always}-rules set this variable to
the empty list. For additionally implemented rules, the documentation
of that rule must specify what it puts into \texttt{trigger}.

\item[\texttt{patternTriggers}] is only set, if the command was
derived as a default command by consulting pattern-rules
(section~\ref{secSuffixAsDefCmd}). It is set to whatever the
\texttt{GenMatch$deptag$} function returned when the default command
was selected. The default implementation of \texttt{GenMatch$deptag$}
returns the list of dependencies which matched the glob-pattern
\texttt{*$deptag$}.
\end{description}

After setting those variables and changing to the right directory, a
rule's command list is executed. Non-internal commands are
automatically passed to \texttt{exec}. But please remember that
\bras{} is basically Tcl and unlike \texttt{sh}, it does no globbing
on the command line. Consequently, the rule
\begin{verbatim}
    Always clean {} {
      rm -f *.o *.a *~
    }
\end{verbatim}
does not work as expected. You have to resort to
\begin{verbatim}
   Always clean {}
      rm -f [glob -nocomplain -- *.o *.a *~]
    }
\end{verbatim}
    
A delicate problem is variable substitution in
external commands. Suppose \texttt{CFLAGS} is set to 
\texttt{"-g -Wall"} and there is a command like 

\begin{verbatim}
    cc $CFLAGS -c $target
\end{verbatim}

If external commands were only \texttt{exec}'ed you could \textbf{not}
expect this to work, because it were equivalent to the tcl-script

\begin{verbatim}
    exec cc $CFLAGS -c $deps
\end{verbatim}

which calls \texttt{cc} with just 3 arguments resulting effectively in

\begin{verbatim}
    cc "-g -Wall" -c whatever.c
\end{verbatim}

To make it work, \bras{} actually does

\begin{verbatim}
    eval exec cc $CFLAGS -c $target
\end{verbatim}

but beware of unwanted flattening in commands containing braces: Due
to \texttt{eval} one level of braces
disappears and

\begin{verbatim}
    sed -e {s/^[/]*//} bla >bli
\end{verbatim}

is flattened by \texttt{eval} to

\begin{verbatim}
    exec -e s/^[/]*// bla >bli
\end{verbatim}

resulting in complaints about the unknown command in
\texttt{[/]}. The remedy is an extra level of braces. While this might
seem clumsy, I find it still much more elegant than the backslashing
necessary in makefiles.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementing New Types of Rules}
\label{secNewRules}
As mentioned previously, there are situations where the standard
rule-types are not sufficient to describe the necessary reasoning.
New rule-types can be implemented
with \bras{}. \Bras{} has a procedure called \texttt{Defrule} to
define new rule types. It is used similar to Tcl's \texttt{proc}.

The use of \texttt{Defrule} is probably most easily described along a
running example. The \texttt{DependsFile}-rule will be used here.
\begin{verbatim}
  Defrule DependsFile {target _reason deps _trigger} {
    upvar $_trigger trigger
    upvar $_reason reason
    ...
  }
\end{verbatim}

The first paremeter of \texttt{Defrule} is the name of the rule.
\texttt{Defrule} installs a Tcl-\texttt{proc} called
\texttt{Check.DependsFile} which is called by the reasoning process to
check whether a target is out of date according to this rule. A
rule-type may have either two or 4 parameters. The names of these
parameters are given in the second argument to \texttt{Defrule}. Their
meaning is described below.

The third argument is the body of \texttt{Check.DependsFile}. It uses
the two or four parameters to communicate with the resoning process.

The parameters have the following meaning:

\begin{description}
\item[\texttt{target}] is the target for which the check has to be
  performed.

\item[\texttt{reason}] is an output variable. The rule must set it to
  descriptive text explaining why the target is out-of-date. It is
  printed by the reasoning process if \bras{} was called with option
  \texttt{-d}. The output is best formatted, if \texttt{reason}
  contains short lines of text \textbf{preceeded} by a newline
  character and without leading whitespace.
  
\item[\texttt{deps}] is only used for four-parameter rule types. When
  called by the reasoning process, this is the list of
  dependencies (not prerequisites). Obviously, rules like
  \texttt{Exist} are never interested in dependencies and consequently
  don't have this parameter. However, if a rule-type is defined with
  four parameters, \bras{} expects it to consider all
  dependencies in turn by calling \texttt{bras.Consider}.
  
\item[\texttt{trigger}] is an output variable which is only used for
  four-parameter rule types. Whatever is put into it can be found by
  the rule's command in the variable \texttt{trigger}, as described in
  section~\ref{secCmdExec}. Its intended use is to communicate those
  dependencies which render the target out-of-date.
\end{description}

The actual body of the new rule-type may contain any Tcl-commands. Of
particular interest may be the \bras{}-internal command
\texttt{bras.Consider}. It takes one argument and considers it as a
target. The result of \texttt{bras.Consider} is either $-1$ indicating
that the argument, considered as a target, needs to be rebuilt, but
that this cannot done. A result of $1$ indicates that the target was
just made and a result of $0$ indicates that the target is up-to-date.

The rule body must return exactly one of those values and they have
the same meaning.

For an example of how a rule-type is implemented, please read the
source of the \texttt{Newer}- or the \texttt{Exist-}rule.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Limitations and Known Bugs}


\begin{enumerate}
\item
Since I did not yet test \bras\ with a really big project like say
\texttt{Xemacs} or \texttt{Tcl/Tk}, I don't know if the recursive
inclusion of many \texttt{brasfile}s will lead to performance
problems.

\item
When sourcing \texttt{brasfile}s from other directories, \bras{}
currently does not construct a local scope for the variables used
there. The effect is that it is not possible to use the same variable
name, e.g.\ \texttt{SRC} and \texttt{OBJ}, in the brasfiles
of all subdirectories. This may be corrected in the future by using a
separate interpreter in every directory.

A workaround is to use in every \texttt{brasfile} an array with a name
patterned after the directory to store variables.

\item 
Parallel execution of several commands (as gnu make's option
\texttt{-j}) is not yet supported.

\item
A hack to translate \texttt{makefile}s to \texttt{brasfile}s is not
yet available.

\item
As normal in Tcl, parameters of \texttt{exec} are not passed through
\texttt{glob}, which may lead to surprising error messages about
non-existing files like \texttt{*.o}.

\item
The rule-files containing default pattern-rules are not very
elaborate.

\item
Although Tcl is a portable platform, \bras{} still contains a few
*nixisms.


\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Name of the Game}

First I wanted to call it \texttt{brassel} which is the imperative of
\texttt{brasseln}, a verb you probably won't find in the
dictionary. You may need to ask someone from around K\"oln, but be
prepared to get the answer that (s)he knows what it means but cannot
explain it. I think the description "`working concentrated, busily but
without stress"' is quite close to the real meaning.

Well, since \texttt{brassel} is much to long for a good
Un*x utility, I shortened it to \bras. It rhymes on the german word \textit{Fa\ss}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Credits}

Some people helped to push \bras{} into the right direction. I
would like to thank them. 

\begin{itemize}
\item \texttt{nemo@gsyc.inf.uc3m.es} (Fco. J. Ballesteros) after
looking at a very early version had the
idea to allow the definition of new types of rules.

\item Jason Gunthorpe \texttt{<jgg@debian.org>} started
experiments to get rid of the \texttt{make/automake}-combination with
\bras{}. The resulting long discussions resulted in several changes
and enhancements of \bras{}. In particular commands to fine-tune the
rule-base were added, the semantics of pattern-rules was revised and
the \texttt{DependsFile}-rule was born.

\item Paul Duffin \texttt{<pduffin@hursley.ibm.com>} insisted in the
  usefulnes of a search path for dependencies. I am not sure if he got
  what he wants, and I am also not sure if it is a necessary
  feature. Maybe I should erase the \texttt{searchpath}-feature along
  with pattern rules and require explicit rules for everthing. It is
  so easy to create explicit rules in a foreach-loop, something which
  is virtually impossible in make.

\end{itemize}

\end{document}
