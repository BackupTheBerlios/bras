#!/bin/sh
# tclsh and wish treat the following line as comment \
exec wish $0 "$@"

##### find tclsh-executable
set TCLSH ?
foreach x [split $env(PATH) :] {
  if {[string match .* $x]} continue
  if {[file executable $x/tclsh]} {
    set TCLSH $x/tclsh
    break
  }
}

rename exec _exec
########################################################################
proc exec {args} {
  puts $args
  eval _exec $args
}
########################################################################
proc apply {w} {
  .paths configure -text [getCurrentSetting]
}
########################################################################
proc lentry {w label labelwidth applyfunction} {
  
  frame $w
  label $w.l -text $label -width $labelwidth  -anchor e
  entry $w.e -width 40

  pack $w.l -side left
  pack $w.e -side left -fill x -expand 1

  bind $w.e <Return> "apply %W"
  bind $w.e <Leave> "apply %W"
  bind $w.e <FocusOut> "apply %W"
  return $w
}
########################################################################
proc installPath {prefix dir} {
  if ![string match /* $dir] {
    set dir [string trimright $prefix /]/$dir
  } 

  return [string trimright $dir /]
}
########################################################################
proc getCurrentSetting {} {
  set prefix [string trim [.a.e get]]
  set exe [installPath $prefix [string trim [.b.e get]]]
  set lib [installPath $prefix [string trim [.c.e get]]]
  set man [installPath $prefix [string trim [.man.e get]]]
  set doc [installPath $prefix [string trim [.d.e get]]]
  set lroot [string trim [.e.e get]]
  
  set res "currently selected destination dirs:\n"
  append res \
      "   executable: $exe\n" \
      "library files: $lib\n" \
      "  manual page: $man\n" \
      "         docu: $doc\n" \
      "    link-root: $lroot\n"
  return $res
}
########################################################################
proc mkdirP {dir} {
  if [file isdir $dir] return

  set parent [file dir $dir]
  if {![file exist $dir] && "$parent"!="$dir"} {
    mkdirP $parent
  }
  if ![file isdir $parent] {
    puts stderr \
	"cannot make directory `$dir' because `$parent' is no dir"
    exit 1
  }
  if [catch "exec mkdir $dir" msg] {
    puts stderr $msg
    exit 1
  }
}
########################################################################
proc clink {dst args} {
  if ![file isdir $dst] return

  set pwd [pwd]
  foreach src $args {
    set srcdir [file dirname $src]
    cd $dst
    set srcname [file tail $src]
    if {[file exist $srcname]} {
      if { "link"!=[file type $srcname] } continue
      _exec rm -f $srcname
    } else {
      ## this removes dangling links
      _exec rm -f $srcname
    }
    puts "creating convenience link:\n   [pwd]/$srcname -> $src"
    _exec >&@stdout ln -s $src .
  }
}
########################################################################
proc Install {} {
  global TCLSH version env

  set today [clock format [clock seconds] -format %Y-%m-%d]

  set prefix [string trim [.a.e get]]
  set exe [installPath $prefix [string trim [.b.e get]]]
  set lib [installPath $prefix [string trim [.c.e get]]]
  set man [installPath $prefix [string trim [.man.e get]]]
  set doc [installPath $prefix [string trim [.d.e get]]]
  set lroot [string trim [.e.e get]]
  mkdirP $exe
  mkdirP $lib
  mkdirP $man
  mkdirP $doc

  ## Yes, we support rpm's RPM_BUILD_ROOT, however it must be
  ## explicitely exported in the spec-file
  foreach dir {lib doc exe man} {
    if {[info exist env(RPM_BUILD_ROOT)]
	&& 0==[string first $env(RPM_BUILD_ROOT) [set $dir]]} {
      set l [string length $env(RPM_BUILD_ROOT)]
      set clean($dir) [string range [set $dir] $l end]
      if {![string match /* $clean($dir)]} {
	set clean($dir) /$clean($dir)
      }
    } else {
      set clean($dir) [set $dir]
    }
  }


  ## copy executable
  exec sed -e "1s,^.\*\$,#!$TCLSH," \
      -e "1,10s,VERSION.*,VERSION $version," \
      -e "1,10s,INSTALLED.*,INSTALLED $today," \
      -e "s, |SRCBASE|, $clean(lib)," bras >$exe/bras
  exec chmod a+rx $exe/bras

  ## copy library files
  eval exec cp [glob *.tcl] $lib
  set ruleFiles [glob -nocomplain rules.*\[a-zA-Z0-9\]]
  eval exec cp $ruleFiles $lib

  ## copy manual page
  exec sed \
      -e "s/|VERDATE|/$version/g" \
      -e "s,|SRCBASE|,$clean(lib),g" \
      -e "s,|DOC|,$clean(doc),g" \
      bras.1 >$man/bras.1

  ## copy documentation and example
  exec cp README doc/bras.ps doc/bras.tex Brasfile $doc

  ## create convenience links
  clink $lroot/bin $clean(exe)/bras
  clink $lroot/man/man1 $clean(man)/bras.1

  puts "\nThank you for joining us"
  puts "\n\n                   (C) 1996 kir@iitb.fhg.de"
  exit 0
}
########################################################################

set in [open .version r]
set version [lindex [read $in] 1]

if [info exist env(HOME)] {
  set home $env(HOME)
} else {
  set home .
}

## If command line arguments are available, these should be prefix and
## lroot. They also trigger non-interactive use.
if {[llength $argv]!=2 && [llength $argv]!=0} {
  puts stderr "usage: $argv0 \[prefix lroot\]"
  exit 1
}
if {[llength $argv]==2} {
  set prefix [lindex $argv 0]
  set lroot [lindex $argv 1]
  set interactive 0
} else {
  set prefix $home/tools/bras-$version
  set lroot $home/tools
  set interactive 1
}

#####
label .intro -justify left -text "
Please specify the directories where the installation shall put
the files. Since there are only a few files, you may want to put them
all into one directory.

However, if you choose `installation prefix' to be /usr or /usr/local,
you may want to specify bin, lib/bras and doc/bras for the executable,
library files and documentation.

If `link root' contains subdirectory bin, a soft-link to the
executable will be created there, so that nobody has to change the
PATH environment variable. Good candidates for `link root' are
/usr/local or /usr, if you don't use them as installation prefix.
"
pack .intro -side top -expand 1

#####
label .warn -justify left -foreground salmon -text "
o Directories are created if necessary.
o Installation will fail, if directories cannot be created.
"
pack .warn -side top -expand 1

#####
lentry .x "tclsh-executable" 30 apply
.x.e insert 0 $TCLSH
lentry .a "installation prefix" 30 apply
.a.e insert 0 $prefix
lentry .b "where to put the executable" 30 apply
lentry .c "where to put files need by bras" 30 apply
lentry .man "where to put the manual page" 30 apply
lentry .d "where to put documentation" 30 apply
lentry .e "link root" 30 apply
.e.e insert 0 $lroot

#####
label .paths \
    -text [getCurrentSetting] \
    -anchor w -justify left \
    -font fixed \
    -relief sunken \
    -padx 10 -pady 4
pack .x .a .b .c .man .d .e -side top -fill x
pack .paths -fill x


frame .buttons
button .install -text "Install" -command Install
button .cancel -text "Cancel" -command exit
pack .install .cancel -side left -expand 1
pack .buttons -fill x

if {!$interactive} {
  .install invoke
  exit 0
}
