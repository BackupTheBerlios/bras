########################################################################
#
# This file is part of bras, a program similar to the (in)famous
# `make'-utitlity, written in Tcl.
#
# Copyright (C) 1996--2000 Harald Kirsch
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# $Revision: 1.6 $, $Date: 2000/12/30 12:13:31 $
########################################################################
## source version and package provide
source [file join [file dir [info script]] .version]

########################################################################

namespace eval ::bras {
  namespace export Make PatternMake
  namespace export Newer PatternNewer
  namespace export Always PatternAlways
  namespace export Exist PatternExist
}
########################################################################

proc ::bras::Make {targets bexp {cmd {}}} {
  ::bras::enterRule $targets {} $bexp $cmd
}
########################################################################
proc ::bras::PatternMake {trexp gendep bexp cmd} {
  ::bras::enterPatternRule $trexp $gendep $bexp $cmd
}
proc Expr {args} {

  set r [expr $args]
  puts "Expr: `$args' --> $r"
  return $r
}
########################################################################
proc ::bras::checkMake {rid theTarget _reason} {
  variable Rule
  variable nspace

  upvar $_reason reason
  #puts "Make: bexp=`$bexp'"

  ## Set up a new namespace for predicates and commands. Whenever a
  ## predicate calls installPredicate, it can install variables within 
  ## this new namespace and set them. That namespace is then used to
  ## execute the rule's command.
  set keptNspace $nspace
  set nspace ::ns[::bras::nextID]
  namespace eval $nspace {
    namespace import ::bras::p::*
  }

  set res 0
  ##
  ## When evaluating bexp, we set the following variables
  ## target -- the target for which this rule was called
  ## targets -- other targets associated with this rule
  ## d -- an automatic dependency generated by a pattern rule
  foreach {targets d b} $Rule($rid,bexp) {
    ## transfer values into private namespace
    set $nspace\::target $theTarget;# set for every boolean
					# expression to avoid
					# interference 
    set $nspace\::targets $targets
    set $nspace\::d $d
    set cmd [concat uplevel \#0 \
		 [list namespace inscope $nspace expr [list $b]]]
    #puts ++++$cmd++++
    ## $b contains user's code, so care must be taken when
    ## running it.
    if {[catch $cmd r]} {
      trimErrorInfo
      append ::errorInfo \
	  "\n    while checking test `$b' for " \
	  "target `$theTarget'---SNIP---"
      return -code error -errorinfo $::errorInfo
    }
    set res [expr {$res || $r}]
  }

  ## If we got some reasoning, keep it
  if {[info exist ::[set nspace]::reason]} {
    set reason [set ::[set nspace]::reason]
  } else {
    set reason "\n(condition gives no reason)"
  }

  ## Now run the command.
  if {$res} {
    set res [::bras::invokeCmd $rid $theTarget $nspace]
  }
  namespace delete $nspace
  set nspace $keptNspace

  return $res
}
########################################################################
#
# Some compatibility rules for rules files which used bras up to and
# including version 0.8.0 .
#
proc ::bras::Newer {targets deps {cmd {}}} {
  Make \
      $targets \
      [concat "\[" older [list $targets] [list $deps] "\]"] \
      $cmd
  #puts "Newer $targets $deps"
}
proc ::bras::PatternNewer {rexp dep cmd} {
  PatternMake $rexp $dep {[older $target $d]} $cmd
}

proc ::bras::Always {targets deps {cmd {}}} {
  Make $targets [concat "\[" true [list $deps] "\]"] $cmd
}

proc ::bras::PatternAlways {rexp dep cmd} {
  PatternMake $rexp $dep {[true $d]} $cmd
}

proc ::bras::Exist {targets {cmd {}}} {
  Make $targets [concat "\[" missing [list $targets] "\]"] $cmd
}

